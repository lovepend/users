case 'attribute_map_tab':
        gridApi_MapAttr.value.stopEditing()
        gridApi_MapAttr.value.forEachNode(node => {
          const mapAttrId = node.data.ATT_ID
          const operator = node.data.OPER // í˜„ìž¬ ì—°ì‚°ìž ê°€ì ¸ì˜¤ê¸°
          // ë§ˆìŠ¤í„°ì–´íŠ¸ë¦¬ë·°íŠ¸ì—ì„œ í•´ë‹¹ ATT_IDì˜ VAL_TYPE ì¡°íšŒ
          const masterAttr = allAttributeList.value.find(attr => attr.ATT_ID === mapAttrId)
          const isMasterAttrNumberType = masterAttr && masterAttr.VAL_TYPE === 'NUMBER'
          const isMasterAttrListType = masterAttr && masterAttr.VAL_TYPE === 'LIST'
          // Attributes Mapì—ì„œ í•´ë‹¹ ATT_IDì˜ UOM_ID ê°’ì´ ìžˆëŠ”ì§€ í™•ì¸
          const linkedAttr = lastSelectecRegiData.value.LNK_ATT
            ? lastSelectecRegiData.value.LNK_ATT.find(item => item.ATT_ID === mapAttrId)
            : null
          const hasUomId = linkedAttr && linkedAttr.UOM_ID
          const currentUomId = hasUomId ? linkedAttr.UOM_ID : null

          // UOM_IDê°€ ìžˆì„ ë•ŒëŠ” ë°˜ë“œì‹œ Master Attributeê°€ VAL_TYPEì´ NUMBER or LIST ì—¬ì•¼ í•¨
          if (hasUomId && !(isMasterAttrNumberType || isMasterAttrListType)) {
            failMsg.push(`The Value Type for that ${mapAttrId} must be "NUMBER" or "LIST".`)
            failCount++
            return // ë‹¤ìŒ ë…¸ë“œ
          }
          if (hasUomId && (isMasterAttrNumberType || isMasterAttrListType)) {
            const rawValueToValidate = String(node.data.VALUE || '') // í˜„ìž¬ VALUE í•„ë“œì˜ ê°’ì„ ë¬¸ìžì—´ë¡œ ê°€ì ¸ì˜´ (null/undefined ëŒ€ë¹„)

            // ðŸš¨ ì •ê·œ í‘œí˜„ì‹ ìˆ˜ì •! ìˆ«ìž(0-9), ì‰¼í‘œ(,), ê³µë°±(\s)ë§Œ í—ˆìš©
            //   ^[\s0-9]+  : ë¬¸ìžì—´ ì‹œìž‘ì€ ê³µë°± ë˜ëŠ” ìˆ«ìžë¡œ
            //   (?:,\s*[0-9]+)*$: ì‰¼í‘œ ì´í›„ì— ê³µë°± 0ê°œ ì´ìƒ, ìˆ«ìž 1ê°œ ì´ìƒ íŒ¨í„´ì´ ë°˜ë³µ (ê³µë°±ë§Œ ì—°ì†ë˜ê±°ë‚˜ ì‰¼í‘œë§Œ ì—°ì†ë˜ëŠ” ê²ƒ ë°©ì§€)
            // const numberCommaAndSpaceRegex = /^\s*[0-9]+(?:\s*,\s*[0-9]+)*(?:\.[0-9]+)?\s*$/
            const numberCommaAndSpaceRegex = /^\s*[0-9]+(?:\.[0-9]+)?(?:\s*,\s*[0-9]+(?:\.[0-9]+)?)*\s*$/
            //                                      ^     ^         ^     ^  // ê³µë°± í—ˆìš© êµ¬ê°„
            // ë§Œì•½ rawValueToValidateê°€ ë¹„ì–´ìžˆì§€ ì•Šê³ , ì •ê·œì‹ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì˜¤ë¥˜
            if (rawValueToValidate.trim() !== '' && !numberCommaAndSpaceRegex.test(rawValueToValidate)) {
              // .trim()ì„ ì •ê·œì‹ ê²€ì‚¬ ì „ì— í•´ë²„ë¦¬ë©´, " 1 , 2 " ê°™ì€ ê°’ì´ "1 , 2"ë¡œ ë°”ë€Œì–´ ê²€ì‚¬ë˜ì–´ ì˜ë„ëŒ€ë¡œ ë  ìˆ˜ ìžˆì§€ë§Œ,
              // í˜„ìž¬ ì •ê·œì‹ì€ ì‹œìž‘/ë ê³µë°±ê¹Œì§€ í—ˆìš©í•˜ë¯€ë¡œ .trim() ì—†ì´ ì›ë³¸ìœ¼ë¡œ ê²€ì‚¬í•˜ëŠ”ê²Œ ë” ì •í™•.
              failMsg.push(
                `For attribute ${mapAttrId}, due to its UOM association, the 'VALUE' must contain only numbers.`
              )
              failCount++
              return // ë‹¤ìŒ ë…¸ë“œ
            }
          }
          // NEW_TAG_YNì´ falseì¼ ë•ŒëŠ” DEF_VAL ê²€ì‚¬X
          if (lastSelectecRegiData.value.NEW_TAG_YN !== false) {
            if (mapAttrId && mappedLnkAttDefValues.has(mapAttrId)) {
              const defVal = mappedLnkAttDefValues.get(mapAttrId)
              if (_.isNil(defVal) || _.isEmpty(defVal)) {
                failMsg.push(`Please set the Default value for the attribute (${mapAttrId}) in Attributes Map.`)
                failCount++
              }
            }
          }

          // VAL_TYPEì´ 'BOOL'ì´ê³  VALUEê°€ boolean íƒ€ìž…ì¸ ê²½ìš° ë¬¸ìžì—´ë¡œ ë³€í™˜
          const val_type = linkedAttrTypeMap.get(node.data.ATT_ID)
          if (val_type === 'BOOL') {
            // VALUEê°€ boolean íƒ€ìž…ì´ ì•„ë‹ ê²½ìš° (string "true"/"false" ë˜ëŠ” ì‹¤ì œ true/falseì—¬ì•¼ í•¨)
            const value = node.data.VALUE
            if (typeof value === 'boolean') {
              // ì´ë¯¸ booleanì¸ ê²½ìš° í†µê³¼ (ë‹¤ìŒ ë¡œì§ì—ì„œ stringìœ¼ë¡œ ë³€í™˜)
            } else if (
              typeof value === 'string' &&
              (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')
            ) {
              // "true" ë˜ëŠ” "false" ë¬¸ìžì—´ì¸ ê²½ìš° í†µê³¼
            } else if (_.isNil(value) || value === '') {
              // null, undefined, ë¹ˆ ë¬¸ìžì—´ì¸ ê²½ìš°ë„ ìœ íš¨í•˜ì§€ ì•Šë‹¤ê³  íŒë‹¨
              failMsg.push(`The attribute '${mapAttrId}' of BOOL Type must be 'true' or 'false'.`)
              failCount++
            } else {
              // ê·¸ ì™¸ì˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê°’
              failMsg.push(`The attribute '${mapAttrId}' of BOOL Type must be 'true' or 'false'.`)
              failCount++
            }
            // ìµœì¢…ì ìœ¼ë¡œ ë°±ì—”ë“œì— ë³´ë‚¼ ë•ŒëŠ” ë¬¸ìžì—´ "true" ë˜ëŠ” "false"ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
            // ìœ„ ìœ íš¨ì„± ê²€ì‚¬ í†µê³¼ í›„ ì§„í–‰
            if (typeof node.data.VALUE === 'boolean') {
              node.data.VALUE = String(node.data.VALUE) // true -> "true", false -> "false"
            }
          }

          let rawValue = node.data.VALUE
          let transformedValue = rawValue // ê¸°ë³¸ê°’ì€ ì›ë³¸ VALUE
          if (_.isNil(node.data.VALUE) || _.isEmpty(node.data.VALUE)) {
            // Not Equal ì¼ ê²½ìš°ëŠ null, empty í—ˆìš©
            if (node.data.OPER !== 'NE') {
              failMsg.push("'VALUE' should be not empty.(Except for 'Not Equal')")
              failCount++
            }
          } else {
            // rawValueê°€ ë¹„ì–´ìžˆì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ì¶”ê°€ ì²˜ë¦¬
            if (operator === 'IN' && isMasterAttrNumberType) {
              // Operatorê°€ 'IN'ì´ê³  NUMBER íƒ€ìž…ì¸ ê²½ìš° ê° ìš”ì†Œì— UOM ë³€í™˜ ì ìš©
              if (Array.isArray(rawValue)) {
                let convertedValues = []
                for (const val of rawValue) {
                  const numericVal = parseFloat(val)
                  if (!isNaN(numericVal) && hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
                    const factor = allUomFactors.get(currentUomId)
                    convertedValues.push(String(numericVal / factor))
                  } else {
                    convertedValues.push(String(val)) // UOM ë³€í™˜ ë¶ˆê°€ì‹œ ì›ë³¸ ìœ ì§€ (ë¬¸ìžì—´)
                  }
                }
                transformedValue = convertedValues.join(',') // ì½¤ë§ˆë¡œ ë‹¤ì‹œ ê²°í•©
              } else {
                // 'IN' ì—°ì‚°ìžì— ëŒ€í•œ ë‹¤ë¥¸ íƒ€ìž… ì²˜ë¦¬ (ì˜ˆì™¸)
                failMsg.push(`'VALUE' for IN operator should be a comma-separated list for attribute ${mapAttrId}.`)
                failCount++
              }
            } else if (operator === 'RANGE' && isMasterAttrNumberType) {
              const rangeParts = String(rawValue).split('~')
              if (rangeParts.length === 2 && !isNaN(parseFloat(rangeParts[0])) && !isNaN(parseFloat(rangeParts[1]))) {
                let convertedStart = rangeParts[0].trim()
                let convertedEnd = rangeParts[1].trim()

                if (hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
                  const factor = allUomFactors.get(currentUomId)
                  convertedStart = String(parseFloat(convertedStart) / factor)
                  convertedEnd = String(parseFloat(convertedEnd) / factor)
                }
                transformedValue = `${convertedStart}~${convertedEnd}`
              } else {
                failMsg.push(`'VALUE' for RANGE operator should be in 'start~end' format for attribute ${mapAttrId}.`)
                failCount++
              }
            } else if (isMasterAttrNumberType) {
              // NUMBER íƒ€ìž…ì´ê³  IN, RANGE ì™¸ ë‹¤ë¥¸ ì—°ì‚°ìžì¸ ê²½ìš°: ì˜¤ì§ ìˆ«ìžë§Œ í—ˆìš©
              // rawValueê°€ ë°°ì—´ì´ê±°ë‚˜ ì½¤ë§ˆ, ë¬¼ê²° í¬í•¨ì‹œ ì—ëŸ¬ ì²˜ë¦¬
              let valueToProcess = Array.isArray(rawValue) ? rawValue : rawValue // ì²« ë²ˆì§¸ ê°’ë§Œ ê°€ì ¸ì˜¤ê±°ë‚˜ ë¬¸ìžì—´ ê·¸ëŒ€ë¡œ
              // ì½¤ë§ˆ(,), ë¬¼ê²°(~) í¬í•¨ ì—¬ë¶€ ì²´í¬
              if (String(valueToProcess).includes(',') || String(valueToProcess).includes('~')) {
                failMsg.push(
                  `'VALUE' for attribute ${mapAttrId} with operator '${operator}' must be a single number without ',' or '~'.`
                )
                failCount++
              } else {
                // UOM ë³€í™˜ ì ìš©
                if (hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
                  const factor = allUomFactors.get(currentUomId)
                  const numericValue = parseFloat(String(valueToProcess))
                  transformedValue = String(numericValue / factor)
                } else {
                  transformedValue = String(valueToProcess)
                }
              }
            } else {
              // ê·¸ ì™¸ì˜ ì¼ë°˜ì ì¸ ê²½ìš° (ë¬¸ìžì—´, ë¶ˆë¦¬ì–¸ ë“± ë˜ëŠ” UOM ë³€í™˜ì´ í•„ìš” ì—†ëŠ” ìˆ«ìž)
              if (Array.isArray(rawValue)) {
                transformedValue = rawValue.join(',')
              } else {
                transformedValue = String(rawValue) // ëª¨ë“  ê°’ì€ ë¬¸ìžì—´ë¡œ ë³€í™˜í•˜ì—¬ ì €ìž¥
              }
            }
          }
          if (failCount > 0) return
          selectedRows.push({ ATT_ID: mapAttrId, OPER: operator, VALUE: transformedValue })
        })
        lastSelectecRegiData.value.MAP_ATT = selectedRows
        break
