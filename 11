<template>
  <div class="w-100 h-100 position-relative">
    <div class="panel m-0 p-0 h-100 bg-white overflow-hidden" style="border-radius: initial">
      <div class="panel-body overflow-hidden px-0 py-0 h-100">
        <div class="d-flex flex-column h-100">
          <div>
            <BasicToolBar
              @create-data="preCreatePBS"
              @update-id="preUpdatePBS"
              @delete-data="preDeletePBS"
              @save-data="preSavePBS"
              :showCreate="true"
              :showUpdateId="true"
              :showDelete="true"
              :showSave="true"
            />
          </div>

          <!-- #region tab-content -->
          <div class="tab-content rounded bg-white flex-1">
            <div class="tab-pane active fade show h-100" id="pbs-root-tab-1" v-if="dataRef1 && dataRef1.length > 0">
              <ag-grid-vue class="w-100 h-100" v-bind="gridBindProps1" v-on="gridOnProps1" />
            </div>
            <div class="tab-pane fade show h-100" id="pbs-root-tab-2" v-if="dataRef2 && dataRef2.length > 0">
              <ag-grid-vue class="w-100 h-100" v-bind="gridBindProps2" v-on="gridOnProps2" />
            </div>
          </div>
          <!-- #endregion tab-content -->
        </div>
      </div>

      <div class="panel-heading bg-dark-400 py-0 pb-2" style="border-radius: initial">
        <!-- #region nav -->
        <ul class="nav nav-pills panel-title custom-nav-pbs pt-0">
          <li class="nav-item" v-if="dataRef1 && dataRef1.length > 0">
            <a
              href="#pbs-root-tab-1"
              data-bs-toggle="tab"
              class="nav-link active fw-bolder text-black rounded-0 mb-3px pt-5px pb-2px px-3"
            >
              {{ dataRef1.find(i => i.PRNT_TAG_IDX === null).TAG_NO }}
            </a>
          </li>
          <li class="nav-item" v-if="dataRef2 && dataRef2.length > 0">
            <a
              href="#pbs-root-tab-2"
              data-bs-toggle="tab"
              class="nav-link text-black rounded-0 mb-3px pt-5px pb-2px px-3"
            >
              {{ dataRef2.find(i => i.PRNT_TAG_IDX === null).TAG_NO }}
            </a>
          </li>
        </ul>
        <!-- #endregion nav -->
      </div>
    </div>
  </div>
</template>
<script setup>
  // Common
  import { onMounted, onBeforeMount, watch, isRef, shallowRef, ref, computed, getCurrentInstance, useAttrs } from 'vue'
  import { storeToRefs } from 'pinia'

  // Store
  import { useAppAuthenticationStore } from '@/stores/app-authentication'

  // Helpers
  import { axiosWrapper } from '@/utils/axios/axios-wrapper'
  import axios from 'axios'
  import { sAlert, sToast } from '@/utils/messages/alert-common'

  // Custom Component
  import BasicToolBar from '@/components/toolBar/BasicToolBar.vue'

  // Global Instance & Variable
  const { userInfo } = storeToRefs(useAppAuthenticationStore())

  //#region Required Define
  defineOptions({ name: 'CommonPbsTree' })

  const props = defineProps({
    proj_no: { type: [String, Object], required: false, default: null },
    fn_filterFromPBS: { type: [Function], required: false, default: null },

    // Auto Created by Modal Wrapper
    var_isModal: { type: [Boolean], required: false, default: null },
    fn_onActionApply: { type: [Function], required: false, default: null },
    fn_onActionClose: { type: [Function], required: false, default: null },
    fn_onShowOverlay: { type: [Function], required: false, default: null },
    fn_onHideOverlay: { type: [Function], required: false, default: null },
    fn_onSetAutoHeight: { type: [Function], required: false, default: null },
  })
  //#endregion Required Define

  //#region Received
  // Project No
  const currProjNoRef = computed({
    get() {
      return props?.proj_no
    },
  })
  //#endregion Received

  //#region Lifecycle Hooks
  // Registers a hook to be called right before the component is to be mounted.
  onBeforeMount(() => {
    if (sAlert?.isVisible()) {
      sAlert.close()
    }
  })

  // Registers a callback to be called after the component has been mounted.
  onMounted(() => {
    getHeaderData()
    getGridData()
  })
  //#endregion Lifecycle Hooks

  //#region 버튼 이벤트
  // New/Create 버튼 클릭
  const preCreatePBS = async function (event) {
    let gridApi = null

    let class_by_id_1 = document.getElementById('pbs-root-tab-1').classList
    let class_by_id_2 = document.getElementById('pbs-root-tab-2').classList

    if (class_by_id_1.contains('active')) {
      gridApi = gridRef1.value
    } else if (class_by_id_2.contains('active')) {
      gridApi = gridRef2.value
    } else {
      return
    }

    gridApi.stopEditing()

    const selectedRows = gridApi.getSelectedRows()

    if (selectedRows.length === 0) {
      sAlert.Warning('Select the parent PBS.')
      return
    }

    const { value: new_tag_no } = await sAlert.Confirm({
      title: 'Enter New PBS ID',
      input: 'text',
      showCancelButton: true,
      inputValidator: value => {
        if (!value) {
          return 'You need to write new PBS ID.'
        }
      },
    })

    if (new_tag_no) {
      createPBS(gridApi, new_tag_no)
    }
  }

  // PBS 생성
  const createPBS = async (gridApi, new_tag_no) => {
    try {
      const selectedRows = gridApi.getSelectedRows()
      const selectedRow = selectedRows[0]

      let url = `/api/Data/PublishDirectCreate`

      let defaultCode = ''
      if (selectedRow.path.length === 1) {
        defaultCode = new_tag_no
      } else if (selectedRow.path.length > 1) {
        const remainingElements = selectedRow.path.slice(1)
        const joinedString = remainingElements.join('')
        const resultString = joinedString + new_tag_no
        defaultCode = resultString
      }

      let bodyData = {
        data: [
          {
            CRTER_NO: userInfo.value.UserID,
            PROJ_NO: currProjNoRef.value,
            TAG_NO: new_tag_no,
            CLS_ID: 'PBS_CLAS',
            PIC_NO: userInfo.value.UserID,
            PRNT_TAG_IDX: selectedRow.TAG_IDX,
            ATTRIBUTES: colDefs.value
              .map(item => {
                if (['CODE'].includes(item.field)) {
                  return {
                    ATT_ID: item.field,
                    VALUE: defaultCode,
                    // UOM_ID: 'string',
                    // VALUE_DBL: 0
                  }
                } else {
                  return
                }
              })
              .filter(item => item !== undefined),
          },
        ],
      }

      let jsonData = await axiosWrapper.post(url, bodyData)

      let addPath = null

      gridApi.forEachNode(node => {
        if (node.data.TAG_IDX === jsonData[0].PRNT_TAG_IDX) {
          addPath = [...node.data.path, jsonData[0].TAG_NO]
        }
      })

      let addData = [
        {
          path: addPath,
          PROJ_NO: jsonData[0].PROJ_NO,
          CLS_ID: jsonData[0].CLS_ID,
          PIC_NO: jsonData[0].PIC_NO,
          TAG_NO: jsonData[0].TAG_NO,
          TAG_DESC: jsonData[0].TAG_DESC,
          TAG_IDX: jsonData[0].TAG_IDX,
          PRNT_TAG_IDX: jsonData[0].PRNT_TAG_IDX,
          ATTRIBUTES: jsonData[0].ATTRIBUTES,
          _id: jsonData[0]._id,
        },
      ]
      jsonData[0].ATTRIBUTES.forEach(attr => {
        addData[0][attr.ATT_ID] = attr.VALUE
      })

      gridApi.applyTransaction({ add: addData })

      let newRowNode = gridApi.getRowNode(jsonData[0]._id)
      newRowNode.setSelected(true)
    } catch (error) {
      if (!(error instanceof axios.AxiosError)) {
        sAlert.Error('Failed to PublishDirectCreate : ' + error.message)
      }
    }
  }

  // Update ID 버튼 클릭
  const preUpdatePBS = async function (event) {
    let gridApi = null

    let class_by_id_1 = document.getElementById('pbs-root-tab-1').classList
    let class_by_id_2 = document.getElementById('pbs-root-tab-2').classList

    if (class_by_id_1.contains('active')) {
      gridApi = gridRef1.value
    } else if (class_by_id_2.contains('active')) {
      gridApi = gridRef2.value
    } else {
      return
    }

    gridApi.stopEditing()

    const selectedRows = gridApi.getSelectedRows()

    if (selectedRows.length === 0) {
      sAlert.Warning('Select PBS.')
      return
    }

    if (!selectedRows[0].PRNT_TAG_IDX) {
      sAlert.Warning('The root PBS ID cannot be updated.')
      return
    }

    const { value: update_tag_no } = await sAlert.Confirm({
      title: 'Enter PBS ID for Update',
      input: 'text',
      // text: selectedRows[0].TAG_NO,
      inputValue: selectedRows[0].TAG_NO,
      showCancelButton: true,
      inputValidator: value => {
        if (!value) {
          return 'You need to write PBS ID for update.'
        }
      },
    })

    if (update_tag_no) {
      if (selectedRows[0].TAG_NO !== update_tag_no) {
        updatePBS(gridApi, update_tag_no)
      }
    }
  }

  // PBS ID 업데이트
  const updatePBS = async (gridApi, update_tag_no) => {
    try {
      const selectedRows = gridApi.getSelectedRows()
      const selectedRow = selectedRows[0]

      let url = `/api/Data/PublishDirectUpdate`

      let bodyData = {
        data: [
          {
            _id: selectedRow._id,
            CRTER_NO: userInfo.value.UserID,
            CHGER_NO: userInfo.value.UserID,
            PROJ_NO: selectedRow.PROJ_NO,
            TAG_IDX: selectedRow.TAG_IDX,
            TAG_NO: update_tag_no,
            CLS_ID: selectedRow.CLS_ID,
            TAG_DESC: selectedRow.TAG_DESC,
            PIC_NO: userInfo.value.UserID,
            PRNT_TAG_IDX: selectedRow.PRNT_TAG_IDX,
            ATTRIBUTES: colDefs.value
              .map(item => {
                if (!['TAG_DESC', '_id'].includes(item.field)) {
                  return {
                    ATT_ID: item.field,
                    VALUE: selectedRow[item.field] ? selectedRow[item.field] : '',
                    // UOM_ID: 'string',
                    // VALUE_DBL: 0
                  }
                } else {
                  return
                }
              })
              .filter(item => item !== undefined),
          },
        ],
      }

      let jsonData = await axiosWrapper.post(url, bodyData)

      getGridData()

      sAlert.Success('The PBS ID has been saved.')
    } catch (error) {
      if (!(error instanceof axios.AxiosError)) {
        sAlert.Error('Failed to PublishDirectUpdate : ' + error.message)
      }
    }
  }

  // Delete 버튼 클릭
  const preDeletePBS = async function (event) {
    let gridApi = null

    let class_by_id_1 = document.getElementById('pbs-root-tab-1').classList
    let class_by_id_2 = document.getElementById('pbs-root-tab-2').classList

    if (class_by_id_1.contains('active')) {
      gridApi = gridRef1.value
    } else if (class_by_id_2.contains('active')) {
      gridApi = gridRef2.value
    } else {
      return
    }

    gridApi.stopEditing()

    const selectedRows = gridApi.getSelectedRows()

    if (selectedRows.length === 0) {
      sAlert.Warning('Select the PBS you want to delete.')
      return
    }

    if (!selectedRows[0].PRNT_TAG_IDX) {
      sAlert.Warning('The root PBS cannot be deleted.')
      return
    }

    let newRowNode = gridApi.getRowNode(selectedRows[0]._id)
    if (newRowNode.group) {
      sAlert.Warning('The PBS exists in the child.')
      return
    }

    let confirmResult = await sAlert.Confirm('It will be deleted immediately. Are you sure you want to delete?')
    if (!confirmResult.isConfirmed) {
      return
    }

    deletePBS(gridApi)
  }

  // PBS 삭제
  const deletePBS = async gridApi => {
    try {
      const selectedRows = gridApi.getSelectedRows()
      const selectedRow = selectedRows[0]

      let url = `/api/Data/PublishDirectDelete`

      let bodyData = {
        data: [
          {
            _id: selectedRow._id,
            PROJ_NO: selectedRow.PROJ_NO,
            TAG_IDX: selectedRow.TAG_IDX,
            TAG_NO: selectedRow.TAG_NO,
            CLS_ID: selectedRow.CLS_ID,
            TAG_DESC: selectedRow.TAG_DESC,
            PIC_NO: selectedRow.PIC_NO,
            PRNT_TAG_IDX: selectedRow.PRNT_TAG_IDX,
            // ATTRIBUTES: [
            //   {
            //     ATT_ID: 'string',
            //     VALUE: 'string',
            //     UOM_ID: 'string',
            //     VALUE_DBL: 0
            //   }
            // ],
            DELETED: true,
            DEL_USER: userInfo.value.UserID,
          },
        ],
      }

      let jsonData = await axiosWrapper.post(url, bodyData)

      if (jsonData[0].DELETED === true) {
        gridApi.applyTransaction({ remove: selectedRows })
      }
    } catch (error) {
      if (!(error instanceof axios.AxiosError)) {
        sAlert.Error('Failed to PublishDirectDelete : ' + error.message)
      }
    }
  }

  // Save Changes 버튼 클릭
  const preSavePBS = async () => {
    let gridApi = null

    let class_by_id_1 = document.getElementById('pbs-root-tab-1').classList
    let class_by_id_2 = document.getElementById('pbs-root-tab-2').classList

    if (class_by_id_1.contains('active')) {
      gridApi = gridRef1.value
    } else if (class_by_id_2.contains('active')) {
      gridApi = gridRef2.value
    } else {
      return
    }

    gridApi.stopEditing()

    savePBS(gridApi)
  }

  // PBS 전체 업데이트
  const savePBS = async gridApi => {
    try {
      let url = `/api/Data/PublishDirectUpdate`

      let saveData = []

      gridApi.forEachNode(node => {
        saveData.push({
          _id: node.data._id,
          CRTER_NO: userInfo.value.UserID,
          CHGER_NO: userInfo.value.UserID,
          PROJ_NO: node.data.PROJ_NO,
          TAG_IDX: node.data.TAG_IDX,
          TAG_NO: node.data.TAG_NO,
          CLS_ID: node.data.CLS_ID,
          TAG_DESC: node.data.TAG_DESC,
          PIC_NO: userInfo.value.UserID,
          PRNT_TAG_IDX: node.data.PRNT_TAG_IDX,
          ATTRIBUTES: colDefs.value
            .map(item => {
              if (!['TAG_DESC', '_id'].includes(item.field)) {
                return {
                  ATT_ID: item.field,
                  VALUE: node.data[item.field] ? node.data[item.field] : '',
                  // UOM_ID: 'string',
                  // VALUE_DBL: 0
                }
              } else {
                return
              }
            })
            .filter(item => item !== undefined),
        })
      })

      let bodyData = {
        data: saveData,
      }

      let jsonData = await axiosWrapper.post(url, bodyData)

      sAlert.Success('The PBS data has been saved.')
    } catch (error) {
      if (!(error instanceof axios.AxiosError)) {
        sAlert.Error('Failed to PublishDirectUpdate : ' + error.message)
      }
    }
  }
  //#endregion 버튼 이벤트

  //#region AG Grid 이벤트
  // cellClicked 이벤트
  const onCellClicked = event => {
    // const gridApi = event.api;
    const node = event.node

    // const selectedRows = gridApi.getSelectedRows();
    // if (selectedRows.length === 0) { return }
    // const selectedRow = selectedRows[0];
    // if (selectedRow._id === node.data._id) { return; }

    const headerName = event.colDef.headerName
    if (headerName === 'HASOBJECT') {
      // 클릭된 셀의 DOM 요소 접근
      const cellElement = event.event.target.closest('.ag-cell')

      if (cellElement) {
        // 셀 안의 특정 태그 (예: span) 가져오기
        const customTag = cellElement.querySelector('.form-check-input')

        if (customTag) {
          const newValue = customTag.checked ? 'true' : 'false'
          node.setDataValue('HASOBJECT', newValue)
        }
      }
    }

    let isRoot = !node.data.PRNT_TAG_IDX ? true : false
    let rootId = node.data?.path?.[0]
    let dataToSend = []

    dataToSend.push({ TAG_IDX: node.data.TAG_IDX, CODE: node.data.CODE })

    node.allLeafChildren.forEach(element => {
      dataToSend.push({ TAG_IDX: element.data.TAG_IDX, CODE: node.data.CODE })
    })

    if (props.fn_filterFromPBS) {
      props.fn_filterFromPBS(isRoot, dataToSend, rootId)
    }
  }

  // onSelectionChanged 이벤트
  // autoGroupColumnDef에서 cellRendererParams을 통해 정의 한 checkbox의 경우 cellClicked 이벤트가 실행되지 않기 때문에 onSelectionChanged 이벤트로 Custom
  const onSelectionChanged = event => {
    const source = event.source

    if (source === 'checkboxSelected') {
      // const selectedRows = event.api.getSelectedRows();
      const selectedNodes = event.api.getSelectedNodes()

      if (selectedNodes.length > 0) {
        const selectedNode = selectedNodes[0]

        const node = selectedNode

        let isRoot = !node.data.PRNT_TAG_IDX ? true : false
        let rootId = node.data?.path?.[0]
        let dataToSend = []

        dataToSend.push(node.data.TAG_IDX)

        node.allLeafChildren.forEach(element => {
          dataToSend.push(element.data.TAG_IDX)
        })

        if (props.fn_filterFromPBS) {
          props.fn_filterFromPBS(isRoot, dataToSend, rootId)
        }
      }
    }
  }

  // cellValueChanged 이벤트
  const onCellValueChanged = async params => {
    let gridApi = null

    let class_by_id_1 = document.getElementById('pbs-root-tab-1').classList
    let class_by_id_2 = document.getElementById('pbs-root-tab-2').classList

    if (class_by_id_1.contains('active')) {
      gridApi = gridRef1.value
    } else if (class_by_id_2.contains('active')) {
      gridApi = gridRef2.value
    } else {
      return
    }

    if (params.column.getColId() === 'CODE') {
      if (params.rowIndex === 0) {
        params.node.setDataValue('CODE', '')

        sAlert.Warning(`Root CODE can't be changed.`)
        return
      } else {
        if (!params.data.CODE) {
          params.node.setDataValue('CODE', params.oldValue)

          sAlert.Warning(`You can't enter an empty value.`)
          return
        } else {
          // 중복 등록 방지
          gridApi.forEachNode(function (rowNode, index) {
            if (rowNode.rowIndex !== params.rowIndex && rowNode.data.CODE === params.data.CODE) {
              params.node.setDataValue('CODE', params.oldValue)

              sAlert.Warning('The same CODE already exists.')
              return
            }
          })
        }
      }
    }
  }
  //#endregion AG Grid 이벤트

  //#region Function
  // AG Grid columnDefs 정의
  const getHeaderData = async () => {
    colDefs.value = [
      { field: 'TAG_DESC', headerName: 'PBS Desc', minWidth: 100, editable: true },
      { field: '_id', hide: true },
    ]

    try {
      let url = `/api/ObjectClass/Get`

      const bodyData = {
        ProjectNo: currProjNoRef.value,
        ContainDeleted: false,
      }

      let jsonData = await axiosWrapper.post(url, bodyData)

      let lnk_att = jsonData.find(i => i.CLS_ID === 'PBS_CLAS')?.LNK_ATT

      lnk_att.forEach(element => {
        if (element.ATT_ID === 'HASOBJECT') {
          colDefs.value.push({
            field: element.ATT_ID,
            headerName: element.ATT_ID,
            minWidth: 100,
            cellRenderer: params => {
              return `
                <div>
                  <input class="form-check-input custom-form-check-input-pbs mt-1" type="checkbox"
                  ${params.value && JSON.parse(params.value) ? 'checked' : ''}
                  />
                </div>
              `
            },
          })
        } else {
          colDefs.value.push({ field: element.ATT_ID, headerName: element.ATT_ID, minWidth: 100, editable: true })
        }
      })
    } catch (error) {
      colDefs.value = [
        { field: 'TAG_DESC', headerName: 'PBS Desc', minWidth: 100, editable: true },
        { field: '_id', hide: true },
      ]

      if (!(error instanceof axios.AxiosError)) {
        sAlert.Error('Failed to ObjectClass : ' + error.message)
      }
    }
  }

  // AG Grid rowData 가져오기
  const getGridData = async () => {
    try {
      let url = `/api/Data/GetPubDataByClass`

      const bodyData = {
        ProjectNo: currProjNoRef.value,
        CLS_ID: 'PBS_CLAS',
        ContainDeleted: false,
      }

      let jsonData = await axiosWrapper.post(url, bodyData)

      if (jsonData.length === 0) {
        let confirmResult = await sAlert.Confirm('현재 프로젝트에는 PBS Data가 없습니다. 기본 PBS를 생성하시겠습니까?')
        if (!confirmResult.isConfirmed) {
          return
        }

        let urlCreate = `/api/Data/PublishDirectCreate`

        let bodyDataCreate = {
          data: [
            {
              CRTER_NO: userInfo.value.UserID,
              PROJ_NO: currProjNoRef.value,
              TAG_NO: `SYSTEM PBS`,
              CLS_ID: 'PBS_CLAS',
              PIC_NO: userInfo.value.UserID,
              ATTRIBUTES: [
                // {
                //   ATT_ID: 'string',
                //   VALUE: 'string',
                //   UOM_ID: 'string',
                //   VALUE_DBL: 0
                // }
              ],
            },
            {
              CRTER_NO: userInfo.value.UserID,
              PROJ_NO: currProjNoRef.value,
              TAG_NO: `ASSEMBLY PBS`,
              CLS_ID: 'PBS_CLAS',
              PIC_NO: userInfo.value.UserID,
              ATTRIBUTES: [
                // {
                //   ATT_ID: 'string',
                //   VALUE: 'string',
                //   UOM_ID: 'string',
                //   VALUE_DBL: 0
                // }
              ],
            },
          ],
        }

        let jsonDataCreate = await axiosWrapper.post(urlCreate, bodyDataCreate)

        jsonData = await axiosWrapper.post(url, bodyData)
      }

      const transformedData = await buildTagPaths(jsonData)

      const finalData = await groupByRootSubtree(transformedData)

      finalData.forEach(element => {
        element.forEach(ele => {
          ele.ATTRIBUTES.forEach(attr => {
            ele[attr.ATT_ID] = attr.VALUE
          })
        })
      })

      dataRef1.value = finalData[0] ? finalData[0] : []
      dataRef2.value = finalData[1] ? finalData[1] : []
    } catch (error) {
      dataRef1.value = []
      dataRef2.value = []

      if (!(error instanceof axios.AxiosError)) {
        sAlert.Error('Failed to GetPubDataByClass : ' + error.message)
      }
    }
  }
  //#endregion Function

  //#region Helper
  // AG Grid Tree Data 형식으로 변환
  const buildTagPaths = data => {
    const result = []

    // 경로를 찾는 재귀 함수
    const findPath = (tag, path) => {
      path.push(tag.TAG_NO) // TAG_NO를 경로에 추가
      result.push({
        path: [...path],
        TAG_NO: tag.TAG_NO,
        TAG_DESC: tag.TAG_DESC,
        TAG_IDX: tag.TAG_IDX,
        PRNT_TAG_IDX: tag.PRNT_TAG_IDX,
        ATTRIBUTES: tag.ATTRIBUTES,
        PROJ_NO: tag.PROJ_NO,
        CLS_ID: tag.CLS_ID,
        PIC_NO: tag.PIC_NO,
        _id: tag._id,
      })

      // 하위 태그를 찾아서 경로를 계속 탐색
      for (const child of data) {
        if (child.PRNT_TAG_IDX === tag.TAG_IDX) {
          findPath(child, path)
        }
      }

      path.pop() // 현재 태그 경로에서 제거
    }

    // 최상위 태그들에 대해 경로 찾기 시작
    for (const tag of data) {
      if (tag.PRNT_TAG_IDX === null) {
        findPath(tag, [])
      }
    }

    return result
  }

  // 루트 노드를 기준으로 해당 루트에서 파생된 모든 하위 노드를 하나의 배열로 반환 (루트별 묶음)
  function groupByRootSubtree(data) {
    // 1. 맵을 만들어 노드를 TAG_IDX로 빠르게 접근 가능하게 함
    const map = {}
    data.forEach(item => {
      map[item.TAG_IDX] = { ...item, children: [] }
    })

    // 2. 부모-자식 연결
    data.forEach(item => {
      if (item.PRNT_TAG_IDX) {
        map[item.PRNT_TAG_IDX].children.push(map[item.TAG_IDX])
      }
    })

    // 3. 서브트리 순회하여 모든 노드를 flat하게 수집
    function collectSubtreeNodes(node, result = []) {
      result.push({
        path: node.path,
        TAG_NO: node.TAG_NO,
        TAG_DESC: node.TAG_DESC,
        TAG_IDX: node.TAG_IDX,
        PRNT_TAG_IDX: node.PRNT_TAG_IDX,
        ATTRIBUTES: node.ATTRIBUTES,
        PROJ_NO: node.PROJ_NO,
        CLS_ID: node.CLS_ID,
        PIC_NO: node.PIC_NO,
        _id: node._id,
      })
      node.children.forEach(child => collectSubtreeNodes(child, result))
      return result
    }

    // 4. 루트 노드 기준으로 묶음
    const rootNodes = data.filter(item => item.PRNT_TAG_IDX === null)
    const grouped = rootNodes.map(root => collectSubtreeNodes(map[root.TAG_IDX]))

    return grouped
  }
  //#endregion Helper

  //#region AG Grid Define
  const dataRef1 = ref([])
  const dataRef2 = ref([])

  const gridRef1 = shallowRef(null)
  const gridRef2 = shallowRef(null)

  const colDefs = ref([])

  const themeClass = 'ag-theme-custom'

  const getRowId = params => {
    return params.data._id
  }

  const gridBindProps1 = ref({
    getRowId: getRowId,
    columnDefs: colDefs,
    autoGroupColumnDef: {
      headerName: 'PBS ID',
      minWidth: 200,
      cellRendererParams: {
        checkbox: true,
        innerRenderer: params => {
          return (
            '<i class="fas fa-folder-open text-warning" style="margin-right: 5px;"></i>' +
            `<span class="text-primary fw-bolder">` +
            params.value +
            `</span`
          )
        },
        suppressCount: true,
      },
    },
    onSelectionChanged: onSelectionChanged,
    rowData: dataRef1,
    treeData: true,
    groupDefaultExpanded: -1,
    enableGroupEdit: true,
    getDataPath: data => data.path,
    class: themeClass,
    rowSelection: 'single',
    defaultColDef: {
      editable: false,
      flex: 2,
    },
    statusBar: {
      statusPanels: [
        { statusPanel: 'agTotalRowCountComponent' },
        { statusPanel: 'agFilteredRowCountComponent' },
        { statusPanel: 'agSelectedRowCountComponent' },
      ],
    },
    suppressRowTransform: true,
    pagination: false,
    rowDragManaged: true,
    rowMultiSelectWithClick: false,
    columnHoverHighlight: true,
    suppressRowClickSelection: false,
    suppressLastEmptyLineOnPaste: true,
    enableRangeSelection: false,
    undoRedoCellEditing: true,
    undoRedoCellEditingLimit: 20,
  })

  const gridBindProps2 = ref({
    getRowId: getRowId,
    columnDefs: colDefs,
    autoGroupColumnDef: {
      headerName: 'PBS ID',
      minWidth: 200,
      cellRendererParams: {
        checkbox: true,
        innerRenderer: params => {
          return (
            '<i class="fas fa-folder-open text-warning" style="margin-right: 5px;"></i>' +
            `<span class="text-primary fw-bolder">` +
            params.value +
            `</span`
          )
        },
        suppressCount: true,
      },
    },
    onSelectionChanged: onSelectionChanged,
    rowData: dataRef2,
    treeData: true,
    groupDefaultExpanded: -1,
    enableGroupEdit: true,
    getDataPath: data => data.path,
    class: themeClass,
    rowSelection: 'single',
    defaultColDef: {
      editable: false,
      flex: 2,
    },
    statusBar: {
      statusPanels: [
        { statusPanel: 'agTotalRowCountComponent' },
        { statusPanel: 'agFilteredRowCountComponent' },
        { statusPanel: 'agSelectedRowCountComponent' },
      ],
    },
    suppressRowTransform: true,
    pagination: false,
    rowDragManaged: true,
    rowMultiSelectWithClick: false,
    columnHoverHighlight: true,
    suppressRowClickSelection: false,
    suppressLastEmptyLineOnPaste: true,
    enableRangeSelection: false,
    undoRedoCellEditing: true,
    undoRedoCellEditingLimit: 20,
  })

  const gridOnProps1 = {
    gridReady: params => {
      gridRef1.value = params.api
    },
    cellClicked: onCellClicked,
    cellValueChanged: onCellValueChanged,
  }

  const gridOnProps2 = {
    gridReady: params => {
      gridRef2.value = params.api
    },
    cellClicked: onCellClicked,
    cellValueChanged: onCellValueChanged,
  }
  //#endregion AG Grid Define
</script>
<style scoped>
  /* 활성화 탭 */
  .custom-nav-pbs.nav-pills .nav-link.active {
    background-color: white;
  }

  /* AG Grid HASOBJECT Custom Checkbox */
  .custom-form-check-input-pbs.form-check-input {
    background-color: var(--ag-checkbox-unchecked-background-color);
    border: solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);
    border-radius: initial;
  }

  /* AG Grid HASOBJECT Custom Checkbox : checked */
  .custom-form-check-input-pbs.form-check-input:checked {
    background-color: var(--ag-checkbox-checked-background-color);
    border-color: var(--ag-checkbox-checked-border-color);
  }

  /* 방법 1: 각 행의 하단 테두리 없애기 */
  /* scoped 스타일을 사용한다면 :deep() 필요 */
  :deep(.ag-row) {
    border-bottom: none !important;
  }

  /* 방법 2: 각 셀의 하단 테두리 없애기 (더 확실할 수 있음) */
  /* scoped 스타일을 사용한다면 :deep() 필요 */
  :deep(.ag-cell) {
    border-bottom: none !important;
  }

  /* 방법 3: 셀 래퍼의 테두리 없애기 (경우에 따라 필요) */
  /* scoped 스타일을 사용한다면 :deep() 필요 */
  :deep(.ag-cell-wrapper) {
    border-bottom: none !important;
  }

  /* 추가: 그리드 전체의 외부 테두리도 없애고 싶다면 */
  /* scoped 스타일을 사용한다면 :deep() 필요 */
  :deep(.ag-root-wrapper) {
    border: none !important;
  }
</style>
