case 'attribute_map_tab':
  // 1. 그리드 편집을 종료하고 현재 입력된 데이터를 확정
  gridApi_MapAttr.value.stopEditing()

  gridApi_MapAttr.value.forEachNode(node => {
    const mapAttrId = node.data.ATT_ID
    const operator = node.data.OPER // 현재 연산자 (EQUALS, IN, RANGE 등)
    
    // 마스터 어트리뷰트 정보 조회
    const masterAttr = allAttributeList.value.find(attr => attr.ATT_ID === mapAttrId)
    const isMasterAttrNumberType = masterAttr && masterAttr.VAL_TYPE === 'NUMBER'
    const isMasterAttrListType = masterAttr && masterAttr.VAL_TYPE === 'LIST'
    
    // UOM 정보 확인
    const linkedAttr = lastSelectecRegiData.value.LNK_ATT
      ? lastSelectecRegiData.value.LNK_ATT.find(item => item.ATT_ID === mapAttrId)
      : null
    const hasUomId = linkedAttr && linkedAttr.UOM_ID
    const currentUomId = hasUomId ? linkedAttr.UOM_ID : null

    // [유효성 검사 1] UOM 설정 시 타입 제한
    if (hasUomId && !(isMasterAttrNumberType || isMasterAttrListType)) {
      failMsg.push(`The Value Type for that ${mapAttrId} must be "NUMBER" or "LIST".`)
      failCount++
      return 
    }

    // [유효성 검사 2] 숫자 및 연산자별 형식(IN, RANGE) 검사
    if (hasUomId && (isMasterAttrNumberType || isMasterAttrListType)) {
      const rawValueToValidate = String(node.data.VALUE || '').trim()

      if (rawValueToValidate !== '') {
        // 기본 숫자 패턴 (정수, 실수, 공백 허용)
        const numberPattern = "[0-9]+(?:\\.[0-9]+)?"
        
        if (operator === 'IN') {
          /**
           * IN 연산자: 쉼표(,)로 연결된 2개 이상의 숫자
           */
          const inRegex = new RegExp(`^\\s*${numberPattern}(?:\\s*,\\s*${numberPattern})+\\s*$`)
          if (!inRegex.test(rawValueToValidate)) {
            failMsg.push(`For 'IN' operator in ${mapAttrId}, at least two numbers separated by a comma are required (e.g., 0.1, 0.2).`)
            failCount++
            return
          }
        } else if (operator === 'RANGE') {
          /**
           * RANGE 연산자: 물결표(~)로 연결된 2개의 숫자
           */
          const rangeRegex = new RegExp(`^\\s*${numberPattern}\\s*~\\s*${numberPattern}\\s*$`)
          if (!rangeRegex.test(rawValueToValidate)) {
            failMsg.push(`For 'RANGE' operator in ${mapAttrId}, format must be 'start ~ end' using numbers (e.g., 10 ~ 20.5).`)
            failCount++
            return
          }
        } else {
          /**
           * 기타 연산자 (EQUALS 등): 단일 숫자만 허용
           */
          const singleRegex = new RegExp(`^\\s*${numberPattern}\\s*$`)
          if (!singleRegex.test(rawValueToValidate)) {
            failMsg.push(`For attribute ${mapAttrId}, the value must be a single number.`)
            failCount++
            return
          }
        }
      }
    }

    // [유효성 검사 3] 필수값 체크 (NEW_TAG_YN 기준)
    if (lastSelectecRegiData.value.NEW_TAG_YN !== false) {
      if (mapAttrId && mappedLnkAttDefValues.has(mapAttrId)) {
        const defVal = mappedLnkAttDefValues.get(mapAttrId)
        if (_.isNil(defVal) || _.isEmpty(defVal)) {
          failMsg.push(`Please set the Default value for the attribute (${mapAttrId}) in Attributes Map.`)
          failCount++
        }
      }
    }

    // [데이터 가공 1] BOOL 타입 문자열 변환
    const val_type = linkedAttrTypeMap.get(node.data.ATT_ID)
    if (val_type === 'BOOL') {
      const value = node.data.VALUE
      if (typeof value === 'boolean') {
        node.data.VALUE = String(value)
      } else if (typeof value === 'string' && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        // 통과
      } else if (!(_.isNil(value) || value === '')) {
        failMsg.push(`The attribute '${mapAttrId}' of BOOL Type must be 'true' or 'false'.`)
        failCount++
      }
    }

    // [데이터 가공 2] 최종 저장 값 생성 및 UOM 변환
    let rawValue = node.data.VALUE
    let transformedValue = rawValue 

    if (_.isNil(node.data.VALUE) || _.isEmpty(node.data.VALUE)) {
      if (node.data.OPER !== 'NE') {
        failMsg.push("'VALUE' should be not empty.(Except for 'Not Equal')")
        failCount++
      }
    } else {
      // 1. IN 연산자 데이터 변환 (문자열 -> 배열 -> UOM계산 -> 쉼표문자열)
      if (operator === 'IN' && isMasterAttrNumberType) {
        let items = typeof rawValue === 'string' ? rawValue.replace(/\s/g, '').split(',') : rawValue
        if (Array.isArray(items)) {
          let converted = items.map(val => {
            const num = parseFloat(val)
            if (!isNaN(num) && hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
              return String(num / allUomFactors.get(currentUomId))
            }
            return String(val)
          })
          transformedValue = converted.join(',')
        }
      } 
      // 2. RANGE 연산자 데이터 변환 (문자열 -> ~분리 -> UOM계산 -> ~문자열)
      else if (operator === 'RANGE' && isMasterAttrNumberType) {
        const parts = String(rawValue).split('~')
        if (parts.length === 2) {
          let start = parts[0].trim()
          let end = parts[1].trim()

          if (hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
            const factor = allUomFactors.get(currentUomId)
            start = String(parseFloat(start) / factor)
            end = String(parseFloat(end) / factor)
          }
          transformedValue = `${start}~${end}`
        }
      } 
      // 3. 단일 숫자 및 기타 처리
      else if (isMasterAttrNumberType) {
        let val = Array.isArray(rawValue) ? rawValue[0] : rawValue
        if (hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
          transformedValue = String(parseFloat(String(val)) / allUomFactors.get(currentUomId))
        } else {
          transformedValue = String(val)
        }
      } else {
        transformedValue = Array.isArray(rawValue) ? rawValue.join(',') : String(rawValue)
      }
    }

    if (failCount > 0) return
    selectedRows.push({ ATT_ID: mapAttrId, OPER: operator, VALUE: transformedValue })
  })

  lastSelectecRegiData.value.MAP_ATT = selectedRows
  break
