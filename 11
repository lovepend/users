case 'attribute_map_tab':
  gridApi_MapAttr.value.stopEditing()
  gridApi_MapAttr.value.forEachNode(node => {
    const mapAttrId = node.data.ATT_ID
    const operator = node.data.OPER // 현재 연산자 가져오기
    
    // 마스터어트리뷰트에서 해당 ATT_ID의 VAL_TYPE 조회
    const masterAttr = allAttributeList.value.find(attr => attr.ATT_ID === mapAttrId)
    const isMasterAttrNumberType = masterAttr && masterAttr.VAL_TYPE === 'NUMBER'
    const isMasterAttrListType = masterAttr && masterAttr.VAL_TYPE === 'LIST'
    
    // Attributes Map에서 해당 ATT_ID의 UOM_ID 값이 있는지 확인
    const linkedAttr = lastSelectecRegiData.value.LNK_ATT
      ? lastSelectecRegiData.value.LNK_ATT.find(item => item.ATT_ID === mapAttrId)
      : null
    const hasUomId = linkedAttr && linkedAttr.UOM_ID
    const currentUomId = hasUomId ? linkedAttr.UOM_ID : null

    // UOM_ID가 있을 때는 반드시 Master Attribute가 VAL_TYPE이 NUMBER or LIST 여야 함
    if (hasUomId && !(isMasterAttrNumberType || isMasterAttrListType)) {
      failMsg.push(`The Value Type for that ${mapAttrId} must be "NUMBER" or "LIST".`)
      failCount++
      return 
    }

    if (hasUomId && (isMasterAttrNumberType || isMasterAttrListType)) {
      const rawValueToValidate = String(node.data.VALUE || '') 

      // 정규 표현식: 숫자, 소수점, 쉼표, 공백 허용 및 연속된 소수점 포함 숫자 나열 검증
      const numberCommaAndSpaceRegex = /^\s*[0-9]+(?:\.[0-9]+)?(?:\s*,\s*[0-9]+(?:\.[0-9]+)?)*\s*$/
      
      if (rawValueToValidate.trim() !== '' && !numberCommaAndSpaceRegex.test(rawValueToValidate)) {
        failMsg.push(
          `For attribute ${mapAttrId}, due to its UOM association, the 'VALUE' must contain only numbers.`
        )
        failCount++
        return 
      }
    }

    // NEW_TAG_YN이 false일 때는 DEF_VAL 검사X
    if (lastSelectecRegiData.value.NEW_TAG_YN !== false) {
      if (mapAttrId && mappedLnkAttDefValues.has(mapAttrId)) {
        const defVal = mappedLnkAttDefValues.get(mapAttrId)
        if (_.isNil(defVal) || _.isEmpty(defVal)) {
          failMsg.push(`Please set the Default value for the attribute (${mapAttrId}) in Attributes Map.`)
          failCount++
        }
      }
    }

    // VAL_TYPE이 'BOOL' 처리
    const val_type = linkedAttrTypeMap.get(node.data.ATT_ID)
    if (val_type === 'BOOL') {
      const value = node.data.VALUE
      if (typeof value !== 'boolean' && 
          !(typeof value === 'string' && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) &&
          !(_.isNil(value) || value === '')) {
        failMsg.push(`The attribute '${mapAttrId}' of BOOL Type must be 'true' or 'false'.`)
        failCount++
      }
      if (typeof node.data.VALUE === 'boolean') {
        node.data.VALUE = String(node.data.VALUE)
      }
    }

    let rawValue = node.data.VALUE
    let transformedValue = rawValue 

    if (_.isNil(node.data.VALUE) || _.isEmpty(node.data.VALUE)) {
      if (node.data.OPER !== 'NE') {
        failMsg.push("'VALUE' should be not empty.(Except for 'Not Equal')")
        failCount++
      }
    } else {
      // --- 데이터 변환 로직 시작 ---
      
      // [수정 포인트] IN 연산자일 때 문자열이 들어오면 공백 제거 후 배열로 변환
      let valueToProcess = rawValue;
      if (operator === 'IN' && typeof rawValue === 'string') {
        valueToProcess = rawValue.replace(/\s/g, '').split(',');
      }

      if (operator === 'IN' && isMasterAttrNumberType) {
        // 이제 배열인 경우(또는 위에서 변환된 경우) 처리
        if (Array.isArray(valueToProcess)) {
          let convertedValues = []
          for (const val of valueToProcess) {
            const numericVal = parseFloat(val)
            if (!isNaN(numericVal) && hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
              const factor = allUomFactors.get(currentUomId)
              convertedValues.push(String(numericVal / factor))
            } else {
              convertedValues.push(String(val))
            }
          }
          transformedValue = convertedValues.join(',')
        } else {
          // 배열이 아니거나 변환에 실패한 경우
          failMsg.push(`'VALUE' for IN operator should be a comma-separated list for attribute ${mapAttrId}.`)
          failCount++
        }
      } else if (operator === 'RANGE' && isMasterAttrNumberType) {
        const rangeParts = String(rawValue).split('~')
        if (rangeParts.length === 2 && !isNaN(parseFloat(rangeParts[0])) && !isNaN(parseFloat(rangeParts[1]))) {
          let convertedStart = rangeParts[0].trim()
          let convertedEnd = rangeParts[1].trim()

          if (hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
            const factor = allUomFactors.get(currentUomId)
            convertedStart = String(parseFloat(convertedStart) / factor)
            convertedEnd = String(parseFloat(convertedEnd) / factor)
          }
          transformedValue = `${convertedStart}~${convertedEnd}`
        } else {
          failMsg.push(`'VALUE' for RANGE operator should be in 'start~end' format for attribute ${mapAttrId}.`)
          failCount++
        }
      } else if (isMasterAttrNumberType) {
        // 단일 숫자 처리
        let singleVal = Array.isArray(rawValue) ? rawValue[0] : rawValue
        if (String(singleVal).includes(',') || String(singleVal).includes('~')) {
          failMsg.push(
            `'VALUE' for attribute ${mapAttrId} with operator '${operator}' must be a single number without ',' or '~'.`
          )
          failCount++
        } else {
          if (hasUomId && currentUomId && allUomFactors.has(currentUomId)) {
            const factor = allUomFactors.get(currentUomId)
            const numericValue = parseFloat(String(singleVal))
            transformedValue = String(numericValue / factor)
          } else {
            transformedValue = String(singleVal)
          }
        }
      } else {
        // 그 외 일반 타입
        if (Array.isArray(rawValue)) {
          transformedValue = rawValue.join(',')
        } else {
          transformedValue = String(rawValue)
        }
      }
    }

    if (failCount > 0) return
    selectedRows.push({ ATT_ID: mapAttrId, OPER: operator, VALUE: transformedValue })
  })
  lastSelectecRegiData.value.MAP_ATT = selectedRows
  break
