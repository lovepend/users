<script setup>
  // Library - Common
  import { ref, onMounted, onBeforeMount, shallowRef, watch, toRaw, computed } from 'vue'
  import { useRouter, useRoute } from 'vue-router'
  import { storeToRefs } from 'pinia'

  // Library - Layout
  import Splitter from 'primevue/splitter'
  import SplitterPanel from 'primevue/splitterpanel'

  // Util
  import { axiosWrapper } from '@/utils/axios-wrapper'
  import axios from 'axios'
  import * as _ from 'lodash-es'

  // Library - AG Grid
  import AggridLoadingOverlay from '@/components/aggrid/AgGridLoadingOverlay.vue'
  import agDropBoxEditor from '@/components/aggrid/AgDropBoxEditor.vue'
  import AgCustomFilter from '@/components/aggrid/AgCustomFilter.vue'

  // Store
  import { useAppProjectStore } from '@/stores/app-var-project'
  import { useAppAuthenticationStore } from '@/stores/app-authentication'

  // Custom Component
  import SettingToolBar from '@/layouts/components/sidebar/components/DataSettingToolBar.vue'
  import BasicToolBar from '@/components/toolBar/BasicToolBar.vue'

  // Helpers
  import { sAlert, sToast } from '@/utils/alert-common'
  import global from '@/utils/enums/global'

  // Style
  import '@/assets/css/ag-grid-theme-builder.css' // 사용자가 만든 css 파일을 이용해서 테마 정의함
  import 'bootstrap-icons/font/bootstrap-icons.css'
  import 'vue-select/dist/vue-select.css'

  const router = useRouter()
  const route = useRoute()

  const appAuthentication = useAppAuthenticationStore()
  const { userInfo } = appAuthentication

  const selectedAttId = computed({
    get: () => route.query?.att_id,
    set: newValue => null,
  })

  // Basic Toolbar 버튼 숨김여부 동적 설정용
  const isShowCreateBtn = ref(true)
  const isShowMultiCreateBtn = ref(true)
  const isShowDeleteBtn = ref(true)
  const isDisabledDeleteBtn = ref(true)
  const isShowSaveBtn = ref(true)
  const isDisabledSaveBtn = ref(true)

  const paths = ref('ATTRIBUTE'.split(','))

  const isFinishedSearchReference = ref(true)
  const allRegisterlListRef = ref([])
  const registerlListByAttIDRef = ref([])

  // AG GRID
  const firstGridDataModel = ref(null)
  const gridApi_Attribute = shallowRef()
  const gridApi_CodeList = shallowRef()
  const themeClass = 'ag-theme-custom'
  const getRowId = params => {
    return params.data._id
  }
  const refreshParams = {
    force: true,
    suppressFlash: true,
  }

  const uomComboSet = ref({})
  const context = ref()

  const uomList = ref()
  const uomGroupList = ref([])

  const agMultiColumnFilterParams = {
    filters: [
      {
        filter: 'agTextColumnFilter',
        filterParams: {
          buttons: ['reset'],
        },
      },
      {
        filter: 'agSetColumnFilter',
        filterParams: {
          comparator: (a, b) => {
            const valA = parseInt(a)
            const valB = parseInt(b)
            if (valA === valB) return 0
            return valA > valB ? 1 : -1
          },
          buttons: ['reset'],
          valueFormatter: params => {
            // 이 부분을 추가해야 합니다.
            return params.value // keyCreator가 반환하는 값을 그대로 표시
          },
        },
      },
      {
        filter: 'AgCustomFilter',
        filterParams: {
          buttons: ['reset'],
        },
      },
    ],
  }

  const checkClassType = (params, originData, standColumn) => {
    if (originData) {
      let v = originData.find(elem => elem[standColumn] == params.data[standColumn])
      if (v) {
        if (params.colDef.field) {
          if (Array.isArray(v[params.colDef.field])) {
            if (Array.isArray(params.value)) {
              if (v[params.colDef.field].join(',') === params.value.join(',')) {
                return null
              } else {
                return 'hasWork'
              }
            } else {
              if (params.value) {
                return 'hasWork'
              } else {
                return 'hasWorkEmpty'
              }
            }
          } else {
            if (params.value == v[params.colDef.field]) {
              return null
            } else {
              return 'hasWork'
            }
          }
        }
      } else {
        return 'hasWorkEmpty'
      }
    } else {
      return null
    }
  }

  const checkRefEmpty = obj => {
    if (typeof obj === 'number') {
      if (!obj) return false
      else return true
    } else {
      if (!obj) return false
      else if (_.isNil(obj)) return false
      else if (_.isEmpty(obj)) return false
      else if (obj.length == 1 && _.isEmpty(obj[0])) {
        return false
      } else return true
    }
  }

  const makeComboRender = (params, gubn) => {
    const displayValue =
      params.valueFormatted !== undefined && params.valueFormatted !== null ? params.valueFormatted : params.value

    const container = document.createElement('div')
    container.style.display = 'flex'
    container.style.alignItems = 'center'
    container.style.width = '100%'
    container.style.height = '100%'

    let iconClass = 'fa-sm'

    if (gubn === 'dropbox') {
      container.style.justifyContent = 'space-between'
      iconClass = 'fa-sm'
    } else {
      container.style.justifyContent = 'flex-end'
      iconClass = 'fa-xs'
    }

    const valueSpan = document.createElement('span')
    valueSpan.textContent = displayValue ? displayValue : ''
    valueSpan.style.flexGrow = '1'
    valueSpan.style.overflow = 'hidden'
    valueSpan.style.textOverflow = 'ellipsis'
    valueSpan.style.whiteSpace = 'nowrap'

    if (gubn === 'dropbox') {
      valueSpan.classList.add('ms-1')
    }

    container.appendChild(valueSpan)

    const icon = document.createElement('i')
    icon.classList.add('fa', iconClass, 'fa-caret-down', 'me-1', 'text-blue')
    icon.style.flexShrink = '0'

    container.appendChild(icon)

    return container
  }

  var dateFilterParams = {
    minValidDate: '2008-01-08',
    maxValidDate: new Date(new Date().getTime() + 24 * 60 * 60 * 1000),
    comparator: (filterLocalDateAtMidnight, cellValue) => {
      var dateAsString = cellValue.substring(0, 10)
      if (dateAsString == null) return -1
      var dateParts = dateAsString.split('-')
      var cellDate = new Date(Number(dateParts[0]), Number(dateParts[1]) - 1, Number(dateParts[2]))

      if (filterLocalDateAtMidnight.getTime() === cellDate.getTime()) {
        return 0
      }

      if (cellDate < filterLocalDateAtMidnight) {
        return -1
      }

      if (cellDate > filterLocalDateAtMidnight) {
        return 1
      }
      return 0
    },
  }

  const dateFullFormatter = params => {
    let fmt = ''
    if (!!params.value) fmt = new Date(params.value).toLocaleString()
    else fmt = ''
    return fmt
  }

  const loadingOverlayComponentParams = {
    loadingMessage: 'Loading...',
  }

  const createGridRow = (grid, params) => {
    grid.stopEditing()
    //  grid.deselectAll();
    let randomKey = Math.random().toString(36).substring(2, 12)
    let newID = 'new_' + randomKey
    if (params.createID) {
      if (params.rowID) {
        Object.assign(params.newRow, { [params.rowID]: newID })
      } else {
        Object.assign(params.newRow, { _id: newID })
      }
    }
    let lastIdx = grid.getDisplayedRowCount()
    grid.applyTransaction({
      add: [params.newRow],
      addIndex: lastIdx,
    })
    grid.refreshCells(refreshParams)
    grid.ensureIndexVisible(lastIdx, 'bottom')
    if (params.createID) {
      let newRowNode = grid.getRowNode(newID)
      newRowNode.setSelected(true)
    } else {
      grid.forEachNode((rowNode, index) => {
        if (index == lastIdx) {
          rowNode.setSelected(true)
        }
      })
    }
  }

  const createMultiRow1 = (grid, params, rowCount) => {
    grid.stopEditing()
    grid.deselectAll()
    let lastIdx = grid.getDisplayedRowCount()
    let newRow = {}
    let newRowArray = []
    let randomKey = ''
    let newID = ''
    for (let i = 0; i < rowCount; i++) {
      newRow = {}
      if (params.createID) {
        randomKey = Math.random().toString(36).substring(2, 12)
        newID = 'new_' + randomKey
        if (params.rowID) {
          Object.assign(newRow, { [params.rowID]: newID })
        } else {
          Object.assign(newRow, { _id: newID })
        }
      }

      Object.assign(newRow, params.newRow), newRowArray.push(newRow)
    }

    grid.applyTransaction({
      add: newRowArray,
      addIndex: lastIdx,
    })
    if (params.createID) {
      newRowArray.forEach(row => {
        let rowId = row._id
        if (params.rowID) {
          rowId = row[params.rowID]
        }
        let newRowNode = grid.getRowNode(rowId)
        newRowNode.setSelected(true)
      })
    }
    grid.ensureIndexVisible(lastIdx, 'bottom')

    grid.refreshCells(refreshParams)
  }

  const hasDuplicates = (arr, colName) => {
    let newArray = _.uniqBy(arr, colName)
    return newArray.length !== arr.length
  }

  const checkDuplicate = (data = null, fieldName = null, event = null) => {
    if (!data || !fieldName || !event) {
      sAlert.Warning("'checkDuplicate' Data Not Found.")
      return false
    }
    // index != event.rowIndex
    let tic = data.find(
      (elem, index) => compareTwoCase(elem[fieldName], event.newValue) && elem['_id'] !== event.data._id
    )
    if (tic) {
      event.data[event.colDef.field] = event.oldValue
      event.api.stopEditing()
      event.api.redrawRows()
      sAlert.Warning('This is the use of duplicate names.')
      return false
    }

    return true
  }

  const isValidRegexPattern = (patternString, flags = '') => {
    try {
      new RegExp(patternString, flags)
      return true
    } catch (e) {
      if (e instanceof SyntaxError) {
        console.error('잘못된 정규식 패턴입니다:', patternString, '오류:', e.message)
        return false
      }
      throw e
    }
  }

  const upCase = str => {
    return str.toUpperCase()
  }

  const compareTwoCase = (str1, str2) => {
    let word1 = upCase(str1.trim())
    let word2 = upCase(str2.trim())
    if (word1 == word2) {
      return true
    } else {
      return false
    }
  }

  const statusBar = {
    statusPanels: [
      { statusPanel: 'agTotalRowCountComponent' },
      { statusPanel: 'agFilteredRowCountComponent' },
      { statusPanel: 'agSelectedRowCountComponent' },
    ],
  }

  const defaultColDef = ref({
    editable: params => {
      const canEdit = params.data.PROJ_NO === selectedProject.value
      return canEdit
    },
    filter: 'agMultiColumnFilter',
    filterParams: agMultiColumnFilterParams,
    floatingFilter: true,
    cellClass: function (params) {
      return checkClassType(params, firstGridDataModel.value, '_id')
    },
  })
  const defaultColDef2 = {
    filter: true,
    editable: false,
    filterParams: agMultiColumnFilterParams,
  }
  const pagination = false

  const rowClassRules = {
    'bg-row-class-cl': params => {
      return params.data.CL_ID !== null && params.data.CL_ID !== ''
    },
    'bg-row-class-rel': params => {
      return params.data.REL_ID !== null && params.data.REL_ID !== ''
    },
  }
  //UOM 값을 가져오기
  const getUOM = uomGroupId => {
    let comboset = {}
    let keys = []
    uomList.value
      .filter(u => {
        return u.GROUP == uomGroupId
      })
      .forEach(u => {
        comboset[u.UOM_ID] = u.SYMBOL
        keys.push(u.UOM_ID)
      })
    uomComboSet.value = comboset
    return comboset
  }

  //KKJ 241219
  //UOM_GROUP 값을 가져오기
  const getUOMGroup = uomId => {
    const result = uomList.value.find(u => {
      return u.UOM_ID === uomId
    })
    return result
  }

  const colDefs_1 = ref([
    {
      pinned: 'left',
      filter: false,
      headerCheckboxSelection: true,
      headerCheckboxSelectionFilteredOnly: true,
      flex: 1,
      minWidth: 40,
      maxWidth: 40,
      checkboxSelection: params => (params.data.PROJ_NO != selectedProject.value ? false : true),
    },
    {
      headerName: 'Attribute',
      headerClass: 'text-center', // 헤더도 가운데 정렬 하려면 필요함
      field: 'ATT_ID',

      minWidth: 100,
      pinned: 'left',
      // checkboxSelection: true,
      flex: 1,
      valueSetter: params => (params.data.ATT_ID = !!params.newValue ? params.newValue.toUpperCase() : ''),
      valueFormatter: params => (!!params.value ? params.value.toUpperCase() : ''),
      cellRenderer: params => {
        if (params.data.PROJ_NO != selectedProject.value) {
          return `<span class="text-orange-600"><i class="fa fa-layer-group fa-lg me-1"></i>${!!params.value ? params.value.toUpperCase() : ''}</span>`
        } else if (params.data.CL_ID === null || _.isEmpty(params.data.CL_ID)) {
          return `<span class="text-blue-600"><i class="fa fa-layer-group fa-lg me-1"></i>${!!params.value ? params.value.toUpperCase() : ''}</span>`
        } else {
          return `<span class="text-red-800"><i class="fa fa-layer-group fa-lg me-1"></i>${!!params.value ? params.value.toUpperCase() : ''}</span>`
        }
      },
      tooltipValueGetter: params => params.valueFormatted, // cellRenderer에 의해 포맷된 최종 값을 툴팁으로 보여줌
    },
    {
      field: 'GROUP',
      headerName: 'Group',
      minWidth: 150,
      flex: 2,
      tooltipField: 'GROUP', // 'GROUP
      valueSetter: params => {
        if (params.newValue) {
          params.data.GROUP = params.newValue.split(',').map(item => item.trim())
        } else {
          params.data.GROUP = []
        }
        return true
      },
      valueFormatter: params => {
        return Array.isArray(params.value) ? params.value.join(',') : params.value
      },
      filterParams: {
        valueFormatter: params => {
          return Array.isArray(params.value) ? params.value.join(',') : params.value
        },
      },
      tooltipValueGetter: params => params.valueFormatted, // valueFormatter에 의해 포맷된 최종 값을 툴팁으로 보여줌
    },
    {
      field: 'DESC',
      headerName: 'Description',
      minWidth: 220,
      flex: 3,
      tooltipField: 'DESC', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'REMARK',
      headerName: 'Remark',
      minWidth: 180,
      flex: 2,
      tooltipField: 'REMARK', // 필드 값을 그대로 툴팁으로 보여줌
      // tooltipValueGetter: (p) => p.value,
    },
    {
      field: 'VAL_TYPE',
      headerName: 'Value Type',
      minWidth: 120,
      flex: 1,
      cellEditor: 'agSelectCellEditor',
      cellEditorParams: {
        values: Object.keys(global.valueType),
      },
      cellRenderer: params => {
        return makeComboRender(params)
      },
      tooltipField: 'VAL_TYPE', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'ALLOW_STRS',
      headerName: 'Allow String',
      minWidth: 100,
      flex: 2,
      valueSetter: params => {
        if (params.newValue) {
          params.data.ALLOW_STRS = params.newValue.split(',').map(item => item.trim())
        } else {
          params.data.ALLOW_STRS = []
        }
        return true
      },
      valueFormatter: params => {
        return Array.isArray(params.value) ? params.value.join(',') : params.value
      },
      tooltipValueGetter: params => params.valueFormatted, // valueFormatter에 의해 포맷된 최종 값을 툴팁으로 보여줌
    },
    { field: 'IGN_LIST_VAL', headerName: 'Ignore Code', minWidth: 100, flex: 1 },
    {
      field: 'CL_ID',
      headerName: 'Code',
      minWidth: 100,
      flex: 1,
      tooltipField: 'CL_ID', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'REL_ID',
      headerName: 'Rel. Type',
      minWidth: 120,
      flex: 3,
      tooltipField: 'REL_ID', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'REL_DIR',
      headerName: 'Rel. Direction',
      minWidth: 100,
      flex: 3,
      valueFormatter: params => {
        if (params.value === 'LEFT') {
          return 'ORIGIN'
        } else if (params.value === 'RIGHT') {
          return 'DESTINATION'
        }
        return params.value // 그 외 값은 그대로 표시
      },
    },
    {
      field: 'REL_CLS_ID',
      headerName: 'Rel. Class ID',
      minWidth: 100,
      flex: 3,
      tooltipField: 'REL_CLS_ID', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'UOM_GROUP',
      headerName: 'UOM Group',
      minWidth: 120,
      flex: 1.5,
      cellRenderer: params => {
        return makeComboRender(params)
      },
      tooltipField: 'UOM_GROUP', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'UOM_ID',
      headerName: 'UOM',
      minWidth: 80,
      flex: 1,
      headerTooltip: 'Please select UOMGroup first.',
      cellEditor: 'agRichSelectCellEditor',
      cellRenderer: params => {
        // console.log('cellRenderer:', params.value, '->', params.valueFormatted);
        if (params.data && params.data.UOM_GROUP) {
          return makeComboRender(params, 'dropbox')
        }
      },
      valueFormatter: function (params) {
        let result = null
        if (params.value != null && params.value != '') {
          const foundUom = uomList.value.find(u => {
            return u.UOM_ID === params.value || u.SYMBOL === params.value
          })
          if (foundUom) {
            result = foundUom.SYMBOL
          }
        }
        // console.log('valueFormatter:', params.value, '->', result);
        return result
      },
      cellEditorParams: function (params) {
        return {
          values: Object.keys(getUOM(params.node.data.UOM_GROUP)),
          valueListGap: 5,
          allowTyping: true,
          filterList: true,
          highlightMatch: true,
          valueListMaxHeight: 220,
        }
      },
      tooltipValueGetter: params => params.valueFormatted, // valueFormatter에 의해 포맷된 최종 값을 툴팁으로 보여줌
    },
    {
      field: 'SEQ',
      headerName: 'SEQ',
      minWidth: 80,
      flex: 1,
      cellDataType: 'number',
    },
    {
      field: 'REG_EXPS',
      headerName: 'REG_EXPS',
      minWidth: 180,
      flex: 2,
      tooltipField: 'REG_EXPS', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'FORMAT',
      headerName: 'FORMAT',
      minWidth: 180,
      flex: 2,
      tooltipField: 'FORMAT', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'DEF_VAL',
      headerName: 'Default',
      minWidth: 100,
      flex: 1,
      // ,valueSetter: params => { // 지정된 타입을 따르도록 value setter 구현 필요시 주석 제거 후 이용
      //   let result = true;
      //   let val_type = attrListRef.value.find(elem => elem.ATT_ID == params.data.ATT_ID)?.VAL_TYPE;

      //   if (val_type == "NUMBER") {
      //     if (isNaN(params.newValue)) {
      //       sAlert.Warning("Enter Default Value in number type.")
      //       result = false;
      //     } else {
      //       params.data.DEF_VAL = params.newValue;
      //       // if(params.newValue == ""){ params.data.DEF_VAL = params.newValue;}
      //       // params.data.DEF_VAL = (params.newValue * 1).toString();
      //       console.log(params.data.DEF_VAL);
      //     }
      //   } else {
      //     params.data.DEF_VAL = params.newValue
      //   }
      // }
    },
    {
      field: 'CFIHOS_ID',
      headerName: 'CFIHOS_ID',
      minWidth: 220,
      flex: 3,
      tooltipField: 'CFIHOS_ID', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'CFIHOS_NAME',
      headerName: 'CFIHOS_NAME',
      minWidth: 220,
      flex: 3,
      tooltipField: 'CFIHOS_NAME', // 필드 값을 그대로 툴팁으로 보여줌
    },
    {
      field: 'EDIT_PAGE_URL',
      headerName: 'EDIT_PAGE_URL',
      minWidth: 180,
      flex: 2,
      refData: Object.keys(global.brokerUrl).reduce((a, d) => {
        a[d] = global.brokerUrl[d].EXPR
        return a
      }, {}),
      cellEditor: 'agSelectCellEditor',
      cellEditorParams: {
        values: Object.keys(global.brokerUrl),
      },
      cellRenderer: params => {
        return makeComboRender(params)
      },
    },
    {
      field: 'PROJ_NO',
      headerName: 'Project',
      minWidth: 100,
      flex: 1,
      editable: false,
      cellClass: 'agReadOnly',
      hide: true,
    },
    {
      field: 'CRTER_NO',
      headerName: 'CRTER NO',
      editable: false,
      cellClass: 'agReadOnly',
      minWidth: 110,
      flex: 1,
      hide: true,
    },
    {
      field: 'CRTE_DTM',
      headerName: 'CRTE DTM',
      cellDataType: 'date',
      valueFormatter: dateFullFormatter,
      filter: true,
      filter: 'agDateColumnFilter',
      filterParams: dateFilterParams,
      editable: false,
      cellClass: 'agReadOnly',
      hide: true,
    },
    {
      field: 'CHGER_NO',
      headerName: 'CHGER NO',
      editable: false,
      cellClass: 'agReadOnly',
      minWidth: 110,
      flex: 1,
      hide: true,
    },
    {
      field: 'CHGE_DTM',
      headerName: 'CHGE DTM',
      cellDataType: 'date',
      valueFormatter: dateFullFormatter,
      filter: true,
      filter: 'agDateColumnFilter',
      filterParams: dateFilterParams,
      editable: false,
      cellClass: 'agReadOnly',
      hide: true,
    },
    { field: '_id', headerName: 'id', editable: false, hide: true },
    { field: 'STATUS', editable: false, hide: true },
  ])

  const colDefs_2 = ref([
    {
      field: 'PRNT_VALUE',
      headerName: 'Parent Value',
      flex: 1,
      minWidth: 110,
      cellClass: 'agReadOnly',
    },
    {
      field: 'VALUE',
      headerName: 'Value',
      flex: 3,
      minWidth: 100,
      flex: 3,
      cellClass: 'agReadOnly',
    },
    {
      field: 'DESC',
      headerName: 'Description',
      flex: 8,
      minWidth: 200,
      filter: true,
      cellClass: 'agReadOnly',
    },
    {
      field: 'REMARK',
      headerName: 'Remark',
      flex: 6,
      minWidth: 150,
      cellClass: 'agReadOnly',
    },
    // checkbox 정렬 클래스 따로 지정해줘야 함
    {
      headerName: 'USE',
      headerClass: 'text-center',
      field: 'USE_YN',
      minWidth: 80,
      flex: 1,
      cellClass: 'checkbox-center',
      editable: false,
    },
  ])

  /*****		API 통신 			******/
  const { defaultProject } = storeToRefs(useAppProjectStore())

  const attrListRef = ref(null)
  const codeListCombo = ref()
  const relListCombo = ref()
  const clsListCombo = ref()

  //system, template attribute
  const systemAttributeList = ref(_.cloneDeep(global.defaultAttributes))
  const temlAttributeList = ref(_.cloneDeep(global.templateAttributes))
  const codeValueListRef = ref()
  const selectedProject = ref('')

  let changedCells = []

  onBeforeMount(() => {
    if (sAlert?.isVisible()) {
      sAlert.close()
    }
  })

  onMounted(() => {
    if (route.query.proj_no) {
      selectedProject.value = route.query.proj_no
    } else {
      selectedProject.value = defaultProject.value.code
    }
  })

  watch(defaultProject, newProject => {
    if (newProject) {
      selectedProject.value = newProject.code
    } else {
      selectedProject.value = ''
    }

    if (gridApi_Attribute.value) {
      getAttributes()
    }
  })

  const changeColDefs = () => {
    colDefs_1.value.forEach(function (c) {
      if (c.field == 'CL_ID') {
        c.editable = function (param) {
          // 프로젝트가 같으면 나머지 조건 검사
          if (param.data.PROJ_NO === selectedProject.value) {
            return param.data.VAL_TYPE == 'LIST' ||
              param.data.VAL_TYPE == 'CASESET' ||
              param.data.VAL_TYPE == 'DYNAMICLIST'
              ? true
              : false
          }
        }
        c.cellClass = function (param) {
          return param.data.VAL_TYPE == 'LIST' ||
            param.data.VAL_TYPE == 'CASESET' ||
            param.data.VAL_TYPE == 'DYNAMICLIST'
            ? ''
            : 'agReadOnly'
        }
        c.cellRenderer = function (param) {
          return param.data.VAL_TYPE == 'LIST' ||
            param.data.VAL_TYPE == 'CASESET' ||
            param.data.VAL_TYPE == 'DYNAMICLIST'
            ? makeComboRender(param, 'dropbox')
            : ''
        }
        c.cellEditor = 'agDropBoxEditor'
        c.cellEditorParams = {
          listData: codeListCombo.value,
          placeholder: 'Select Code',
          popupDropBoxHeight: 130,
        }
        c.singleClickEdit = true
        c.cellEditorPopup = true
        c.cellEditorPopupPosition = 'over'
      } else if (c.field == 'REL_ID') {
        c.editable = function (param) {
          // 프로젝트가 같으면 나머지 조건 검사
          if (param.data.PROJ_NO === selectedProject.value) {
            return param.data.VAL_TYPE == 'RELATION' ? true : false
          }
        }
        c.cellClass = function (param) {
          return param.data.VAL_TYPE == 'RELATION' ? '' : 'agReadOnly'
        }
        c.cellRenderer = function (param) {
          return param.data.VAL_TYPE == 'RELATION' ? makeComboRender(param, 'dropbox') : ''
        }
        c.cellEditor = 'agDropBoxEditor'
        c.cellEditorParams = {
          listData: relListCombo.value,
          placeholder: 'Select Code',
          popupDropBoxHeight: 130,
        }
        c.singleClickEdit = true
        c.cellEditorPopup = true
        c.cellEditorPopupPosition = 'over'
      } else if (c.field == 'REL_DIR') {
        c.editable = function (param) {
          if (param.data.PROJ_NO === selectedProject.value) {
            return param.data.VAL_TYPE == 'RELATION' ? true : false
          }
        }
        c.cellClass = function (param) {
          return param.data.VAL_TYPE == 'RELATION' ? '' : 'agReadOnly'
        }
        c.cellRenderer = function (param) {
          return param.data.VAL_TYPE == 'RELATION' ? makeComboRender(param, 'dropbox') : ''
        }
        ;(c.cellEditor = 'agSelectCellEditor'),
          (c.cellEditorParams = {
            values: ['LEFT', 'RIGHT'],
          })
      } else if (c.field == 'REL_CLS_ID') {
        c.editable = function (param) {
          if (param.data.PROJ_NO === selectedProject.value) {
            return param.data.VAL_TYPE == 'RELATION' ? true : false
          }
        }
        c.cellClass = function (param) {
          return param.data.VAL_TYPE == 'RELATION' ? '' : 'agReadOnly'
        }
        c.cellRenderer = function (param) {
          return param.data.VAL_TYPE == 'RELATION' ? makeComboRender(param, 'dropbox') : ''
        }
        c.cellEditor = 'agDropBoxEditor'
        c.cellEditorParams = {
          listData: clsListCombo.value,
          placeholder: 'Select Code',
          popupDropBoxHeight: 130,
        }
        c.singleClickEdit = true
        c.cellEditorPopup = true
        c.cellEditorPopupPosition = 'over'
      } else if (c.field == 'UOM_GROUP') {
        c.cellEditor = 'agRichSelectCellEditor'
        c.cellEditorParams = {
          values: uomGroupList.value,
          valueListGap: 5,
          allowTyping: true,
          filterList: true,
          highlightMatch: true,
          valueListMaxHeight: 220,
        }
      }
    })
  }

  // Attribute List를 불러온다.
  const getAttributes = async () => {
    gridApi_Attribute.value.setGridOption('loading', true)
    attrListRef.value = []
    changedCells = []
    if (!selectedProject.value) {
      sAlert.Warning(`Project를  선택해주세요`)
      return
    }
    let url = `/api/Attributes/Get`
    let codeListURL = `/api/CodeList/Get`
    let relURL = `/api/Relation/Get`
    let objClsURL = `/api/ObjectClass/GetByID`
    let uomURL = `/api/UOM/Get`

    try {
      const jsonData_code = await axiosWrapper.post(codeListURL, {
        ProjectNo: selectedProject.value,
        // ContainDeleted: true,
      })
      codeListCombo.value = jsonData_code.map(c => {
        return { code: c.CL_ID, label: `(${c.CL_ID}) ${c.DESC}`, desc: c.DESC }
      })

      const jsonData_Rel = await axiosWrapper.post(relURL, {
        ProjectNo: selectedProject.value,
        // ContainDeleted: true,
      })
      relListCombo.value = jsonData_Rel.map(c => {
        return { code: c.REL_ID, label: `(${c.REL_ID}) ${c.NAME}`, desc: c.NAME }
      })

      const jsonData_Cls = await axiosWrapper.post(objClsURL, {
        ProjectNo: selectedProject.value,
        CLS_ID: 'DOC_CLAS',
        ContainChildren: true,
        // ContainDeleted: true,
      })
      clsListCombo.value = jsonData_Cls.map(c => {
        return { code: c.CLS_ID, label: `(${c.CLS_ID}) ${c.DESC}`, desc: c.DESC }
      })

      uomList.value = await axiosWrapper.post(uomURL, {
        ProjectNo: selectedProject.value,
        // ContainDeleted: true,
      })

      //console.log("uomList.value :: " + JSON.stringify(uomList.value));

      let uomgroup = _.uniqBy(uomList.value, 'GROUP').map(e => e.GROUP)
      uomGroupList.value = uomgroup
      uomList.value.forEach(u => {
        uomComboSet.value[u.UOM_ID] = u.SYMBOL
      })

      changeColDefs()

      const jsonData = await axiosWrapper.post(url, {
        ProjectNo: selectedProject.value,
        // isDeleted: true,
      })


