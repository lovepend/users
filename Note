const insertRows = function (rowCount) {
  const grid = gridRef.value;
  if (!grid) return;

  grid.stopEditing();
  grid.setGridOption('loading', true);

  const filterModel = grid.getFilterModel();
  const filterDefaults = {};

  /**
   * 필터 모델의 구조를 스스로 판단하여 배열/단일값을 리턴하는 함수
   */
  const autoDetectAndExtract = (m) => {
    if (!m || typeof m !== 'object') return { value: null, isArray: false };

    // 1. Set Filter 구조 (values 배열이 있음) -> 배열 확정
    if (Array.isArray(m.values)) {
      return { value: m.values, isArray: true };
    }

    // 2. Multi Filter 구조 (filterType이 multi이거나 filterModels가 있음)
    if (m.filterType === 'multi' || Array.isArray(m.filterModels)) {
      const active = (m.filterModels || []).find(f => f !== null);
      const extracted = autoDetectAndExtract(active);
      // 부모가 multi이므로 자식이 단일값이라도 배열로 감싸서 리턴 (배열 성격 유지)
      return { value: extracted.value, isArray: true };
    }

    // 3. 복합 조건 (conditions)
    if (Array.isArray(m.conditions)) {
      const extracted = autoDetectAndExtract(m.conditions[0]);
      return extracted;
    }
    if (m.condition1) return autoDetectAndExtract(m.condition1);

    // 4. 일반 단일 필터 (filter 속성)
    if (m.filter !== undefined) {
      return { value: m.filter, isArray: false };
    }
    
    // 5. 기타 value 속성
    if (m.value !== undefined) {
      return { value: m.value, isArray: false };
    }

    return { value: null, isArray: false };
  };

  // 모든 필터 모델 순회
  Object.keys(filterModel).forEach((colId) => {
    const { value, isArray } = autoDetectAndExtract(filterModel[colId]);

    if (value !== null) {
      // 대문자 변환 헬퍼
      const toUpper = (v) => (typeof v === 'string' ? v.trim().toUpperCase() : v);

      if (isArray) {
        // 배열 구조로 판명된 경우: 무조건 배열 형태로 리턴
        const arr = Array.isArray(value) ? value : [value];
        filterDefaults[colId] = arr.map(toUpper);
      } else {
        // 단일 구조로 판명된 경우: 단일 값으로 리턴
        filterDefaults[colId] = toUpper(value);
      }
    }
  });

  console.log('자동 감지된 필터 결과:', filterDefaults);

  const addRows = [];
  const numRows = parseInt(rowCount) || 1;

  for (let i = 0; i < numRows; i++) {
    const newId = `new_${Math.random().toString(36).substring(2, 12)}`;
    const newRow = {
      STATUS: 'A',
      PROJ_NO: currentProjNo.value,
      ATT_ID: null,
      CL_ID: null,
      VAL_TYPE: (typeof VAL_TYPES !== 'undefined') ? VAL_TYPES.STRING.VALUE : 'STRING',
      RDON_YN: false,
      IGN_LIST_VAL: false,
      CRTER_NO: userInfo.value?.UserID,
      _id: newId,
      ...filterDefaults 
    };
    addRows.push(newRow);
  }

  if (addRows.length > 0) {
    const result = grid.applyTransaction({ add: addRows });
    grid.refreshCells({ force: true, suppressFlash: true });
    
    if (result.add && result.add.length > 0) {
      grid.setNodesSelected({ nodes: result.add, newValue: true });
      const lastIdx = grid.getDisplayedRowCount() - 1;
      grid.ensureIndexVisible(lastIdx, 'bottom');
    }
  }
  grid.setGridOption('loading', false);
};
