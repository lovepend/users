/**
 * AG-Grid 행 추가 공통 함수 (필터 배열 구조 유지 버전)
 */
const insertRows = function (rowCount) {
  const grid = gridRef.value;
  if (!grid) return;

  grid.stopEditing();
  grid.setGridOption('loading', true);

  const filterModel = grid.getFilterModel();
  const filterDefaults = {};

  /**
   * 필터 모델에서 값을 추출하는 함수
   * @param {object} m 필터 모델 객체
   * @returns {any} 문자열, 숫자 또는 배열 형태의 필터값
   */
  const getFilterValue = (m) => {
    if (!m || typeof m !== 'object') return null;

    // 1. Set Filter 또는 Multi Filter의 values 배열 처리
    if (Array.isArray(m.values)) {
      // 배열 내부의 모든 값을 대문자로 변환하여 반환
      return m.values.map(v => (typeof v === 'string' ? v.trim().toUpperCase() : v));
    }

    // 2. Multi Filter 구조인 경우 내부 filterModels 탐색
    if (m.filterType === 'multi' && Array.isArray(m.filterModels)) {
      // null이 아닌 유효한 필터 모델들을 합침
      const activeFilters = m.filterModels.filter(f => f !== null);
      if (activeFilters.length > 0) {
        // 첫 번째 유효한 필터의 값을 재귀적으로 가져옴
        return getFilterValue(activeFilters[0]);
      }
    }

    // 3. 복합 조건 (AND/OR) 처리
    if (Array.isArray(m.conditions)) {
      return getFilterValue(m.conditions[0]);
    }
    if (m.condition1) return getFilterValue(m.condition1);

    // 4. 단일 값 추출 및 대문자 변환
    const res = m.filter !== undefined ? m.filter : 
                m.value !== undefined ? m.value : null;

    if (res !== null && typeof res === 'string') {
      return res.trim().toUpperCase();
    }
    return res;
  };

  // 모든 필터링된 컬럼 순회
  Object.keys(filterModel).forEach((colId) => {
    const val = getFilterValue(filterModel[colId]);
    if (val !== null) {
      filterDefaults[colId] = val;
    }
  });

  console.log('추출된 필터 데이터 (배열 포함):', filterDefaults);

  const addRows = [];
  const numRows = parseInt(rowCount) || 1;

  for (let i = 0; i < numRows; i++) {
    const newId = `new_${Math.random().toString(36).substring(2, 12)}`;
    const newRow = {
      STATUS: 'A',
      PROJ_NO: currentProjNo.value,
      ATT_ID: null,
      CL_ID: null,
      VAL_TYPE: (typeof VAL_TYPES !== 'undefined') ? VAL_TYPES.STRING.VALUE : 'STRING',
      RDON_YN: false,
      IGN_LIST_VAL: false,
      CRTER_NO: userInfo.value?.UserID,
      _id: newId,
      ...filterDefaults // 필터가 배열이면 배열로, 단일값이면 단일값으로 주입
    };
    addRows.push(newRow);
  }

  if (addRows.length > 0) {
    // addIndex 없이 추가하여 항상 전체 데이터의 마지막에 위치시킴
    const result = grid.applyTransaction({ add: addRows });
    
    grid.refreshCells({ force: true, suppressFlash: true });
    
    if (result.add && result.add.length > 0) {
      grid.setNodesSelected({ nodes: result.add, newValue: true });
      const lastIdx = grid.getDisplayedRowCount() - 1;
      grid.ensureIndexVisible(lastIdx, 'bottom');
    }
  }
  
  grid.setGridOption('loading', false);
};

// 버튼 핸들러 (순서 유지)
const onCreateRows = function () {
  if (!currentProjNo.value) {
    sAlert.Warning(`Project를 선택해주세요`);
    return;
  }
  insertRows(1);
};

const onCreateMultiRows = function (rowCount) {
  if (!currentProjNo.value) {
    sAlert.Warning(`Project를 선택해주세요`);
    return;
  }
  const count = (typeof rowCount === 'number') ? rowCount : 1;
  insertRows(count);
};
