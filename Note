<template>
  <div class="panel mb-0" style="width: 100%">
    <div class="panel-heading border-bottom h-50px" style="background-color: var(--bg07)">
      <span class="fs-2 fw-bold" style="color: var(--basic02)">{{ $t('ReleasedNote_vue.title') }}</span>
    </div>
    <div v-if="userInfo.IsDeveloper" class="h-35px p-0 m-0" style="background-color: var(--bg11); padding: 8px 8px 6px">
      <input
        id="selectedFile"
        class="d-none"
        type="file"
        accept=".xlsx, .xls"
        @change="handleFileUpload($event)"
        ref="fileInput"
      />
      <button class="btn btn-xs btn-gray float-end align-items-center shadow-none me-2 mt-1" @click="importExcel">
        {{ $t('ReleasedNote_vue.import') }}
      </button>
    </div>
    <div class="panel-body py-2 overflow-auto" style="height: calc(100vh - 150px); background-color: var(--bg14)">
      <div class="pt-2 ps-3">
        <template v-if="releaseNotesGrouped.length > 0">
          <div v-for="(versionGroup, groupIndex) in releaseNotesGrouped" :key="groupIndex">
            <span class="fs-3" style="color: var(--txt04)">{{ $t('ReleasedNote_vue.version') }}</span>
            <span class="fs-3 ms-1" style="color: var(--txt04)">{{ versionGroup.version }}</span>
            <span class="fs-5 ps-2" style="color: var(--txt02)">{{ $t('ReleasedNote_vue.update') }}...</span>
            <ul class="pt-2">
              <li v-for="(item, itemIndex) in versionGroup.items" :key="itemIndex">
                <div class="fs-13px">
                  <div class="h-auto mb-1 pt-1 text-white" :class="getBadgeClass(item.category)">
                    {{ item.category }}
                  </div>
                  <div
                    class="border rounded-3 mb-1"
                    :class="getBadgeTextColorClass(item.category) + ' description-text me-2'"
                    style="background-color: var(--basic02)"
                  >
                    <div class="p-1 pb-0">[{{ item.AutoNo }}] : [{{ item.status }}]</div>
                    <div class="p-2 pb-1 fw-normal" style="color: var(--txt03)">{{ item.description }}</div>
                  </div>
                  <div class="border rounded-3 text-cyan-700 mb-1 me-2" style="background-color: var(--basic02)">
                    <div class="p-1 pb-0">{{ $t('ReleasedNote_vue.act_desc') }}</div>
                    <div class="p-2 pb-1 fw-normal" style="color: var(--txt03)">: {{ item.actionDesc }}</div>
                  </div>
                  <div class="border rounded-3 text-green-600 mb-1 me-2" style="background-color: var(--basic02)">
                    <div class="p-1 pb-0">{{ $t('ReleasedNote_vue.dev_desc') }}</div>
                    <div class="p-2 pb-1 fw-normal" style="color: var(--txt03)">: {{ item.remarkDev }}</div>
                  </div>
                </div>
              </li>
            </ul>
            <hr v-if="Number(groupIndex) < releaseNotesGrouped.length - 1" />
          </div>
        </template>
        <template v-else>
          <p v-if="isLoading">{{ $t('ReleasedNote_vue.load_desc') }}</p>
          <p v-else>{{ $t('ReleasedNote_vue.empt_desc') }}</p>
        </template>
      </div>
    </div>
  </div>
  </template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'
import { useAppAuthenticationStore } from '@/stores/app-authentication'
import { axiosWrapper } from '@/utils/axios/axios-wrapper'
import * as XLSX from 'xlsx'
import { ApiCommon } from '@/utils/axios/api-common'
import * as SEF from '@/utils/spread/spread-excel-funtions.js'

/** Variable List */
const route = useRoute()
const releaseNotesGrouped: any = ref([])
const isLoading = ref(true)
const appAuthentication = useAppAuthenticationStore()
const { userInfo } = appAuthentication
const fileInput: any = ref(null)
const fileId: any = ref(null)

const urlList = {
  gfi: '/api/File/Get',
  gfr: '/api/File/Replace',
}

onMounted(() => {
  const baseSiteName = import.meta.env.VITE_BASE_SITENAME
  if (baseSiteName == 'dev') {
    fileId.value = '69827ed36514d58f04e067e7'
  } else if (baseSiteName == 'devop') {
    fileId.value = '698963e8ed2aff6e2771b20d'
  } else {
    fileId.value = '6982ac8ea605319e04771832'
  }
  fetchAndParseExcel()
})

const handleFileUpload = async (event: any) => {
  try {
    const file = event.target.files[0]
    const fileNameLower = file.name.toLowerCase()
    if (!fileNameLower.endsWith('.xlsx') && !fileNameLower.endsWith('.xls')) {
      SEF.setToast('This is not an Excel file. Please select again.</br>(.xlsx or .xls file only)', 'err')
      return
    }
    const setParams: any = { id: fileId.value, File: file }
    const options = { headers: { 'Content-Type': 'multipart/form-data', FileToken: 'frontserver@sh' } }
    await axiosWrapper.post(urlList.gfr, setParams, options).then(() => {
      fetchAndParseExcel()
    })
  } catch (err) {
    SEF.logMng("'handleFileUpload' 함수 오류: ", err, 'err')
  }
}

const importExcel = function () {
  fileInput.value.click()
}

/**
 * 엑셀 시트에서 헤더 이름을 기반으로 데이터를 추출하는 헬퍼 함수
 */
const parseSheetWithHeaders = (sheet: any) => {
  // header: 1 옵션은 데이터를 2차원 배열 형태로 가져옵니다 (예: rows[0]이 헤더행)
  const rows: any[] = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' })
  if (rows.length === 0) return []

  const headers = rows[0] // 첫 번째 행을 헤더로 인식
  const dataRows = rows.slice(1) // 데이터는 두 번째 행부터

  // 헤더 텍스트별 인덱스 매핑 (찾지 못하면 -1)
  const idx = {
    autoNo: headers.indexOf('Auto No'),
    category: headers.indexOf('구분'),
    desc: headers.indexOf('기능 요청 상세 내용'),
    action: headers.indexOf('ACTION 부서 회신 내용'),
    remark: headers.indexOf('Remark(개발)'),
    status: headers.indexOf('STATUS'),
    version: headers.indexOf('완료 버젼'),
    part: headers.indexOf('Part')
  }

  return dataRows.map(row => ({
    AutoNo: idx.autoNo !== -1 ? row[idx.autoNo] : '',
    category: idx.category !== -1 ? row[idx.category] : '',
    description: idx.desc !== -1 ? row[idx.desc] : '',
    actionDesc: idx.action !== -1 ? row[idx.action] : '',
    remarkDev: idx.remark !== -1 ? row[idx.remark] : '',
    status: idx.status !== -1 ? row[idx.status] : '',
    completionVersion: idx.version !== -1 ? row[idx.version] : '',
    part: idx.part !== -1 ? row[idx.part] : ''
  }))
}

const fetchAndParseExcel = async function () {
  try {
    isLoading.value = true
    const options = {
      responseType: 'blob',
      headers: {
        'Content-Type': 'application/json',
        Accept: '*/*',
        FileToken: 'frontserver@sh',
      },
    }
    const bodyData = { id: fileId.value }

    await axiosWrapper.postAll(urlList.gfi, bodyData, options).then((blobData: any) => {
      const match = blobData.headers['content-disposition'].match(/filename="([^"]+)"/)
      const filename = match ? match[1] : null
      const file = new File([blobData.data], filename, { type: blobData.type })

      ApiCommon.postFileDecryptFile({ FILE: file }).then(async (blob: any) => {
        const decFile = new File([blob], file.name, { type: file.type })
        const data = await decFile.arrayBuffer()
        const workbook = XLSX.read(data, { type: 'array' })

        // 시트 1, 2 모두 동적 헤더 방식으로 파싱
        const smartExcelData = parseSheetWithHeaders(workbook.Sheets[workbook.SheetNames[0]])
        const etcDevDescData = workbook.SheetNames[1] 
                               ? parseSheetWithHeaders(workbook.Sheets[workbook.SheetNames[1]]) 
                               : []

        let combinedJsonData = [...smartExcelData, ...etcDevDescData]

        const grouped: any = {}

        combinedJsonData.forEach((row: any) => {
          const statusValue = (row.status ?? '').toString().trim().toUpperCase()
          const versionValue = (row.completionVersion ?? '').toString().trim()

          // 필터: 상태가 대상이고 버전 정보가 있을 때만
          const isStatusMatch = ['FINISH', 'CHECKED', 'READY'].includes(statusValue)

          if (isStatusMatch && versionValue) {
            const version = versionValue.toLowerCase()
            
            if (!grouped[version]) {
              grouped[version] = {
                version: versionValue,
                items: [],
              }
            }

            grouped[version].items.push({
              AutoNo: row.AutoNo,
              category: row.category ? row.category.toLowerCase() : 'unknown',
              description: row.description || 'No Description',
              actionDesc: row.actionDesc || 'No Description',
              remarkDev: row.remarkDev || 'No Description',
              status: row.status,
              part: row.part
            })
          }
        })

        // 정렬 (최신 버전이 위로)
        releaseNotesGrouped.value = Object.values(grouped).sort((a: any, b: any) => {
          return b.version.localeCompare(a.version, undefined, { numeric: true, sensitivity: 'base' })
        })
      })
    })
  } catch (error) {
    console.error('엑셀 파일 로드 및 파싱 중 오류 발생:', error)
    releaseNotesGrouped.value = []
  } finally {
    SEF.onHideOverlay()
    isLoading.value = false
  }
}

const getBadgeClass = (category: any) => {
  switch (category) {
    case '오류': case 'fixed': return 'badge bg-gradient-orange-red'
    case '기능개선': case 'changed': return 'badge bg-gradient-yellow-orange'
    case '신규기능': case 'added': return 'badge bg-gradient-teal-green'
    default: return 'badge'
  }
}

const getBadgeTextColorClass = (category: any) => {
  switch (category) {
    case '오류': case 'fixed': return 'text-danger'
    case '기능개선': case 'changed': return 'text-warning'
    case '신규기능': case 'added': return 'text-success'
    default: return 'text-gray'
  }
}
</script>

<style scoped>
.description-text {
  white-space: pre-wrap;
  word-break: break-word;
}
.badge {
  border-radius: 20px;
  display: inline-block;
  width: 80px;
  height: 30px;
  line-height: 20px;
  margin-right: 10px;
  text-transform: uppercase;
  font-size: 13px;
  font-weight: 700;
  text-align: center;
  padding-top: 5px;
}
ul {
  display: block;
  list-style: none;
  margin: 0;
  padding-left: 0;
}
li {
  margin: 8px 0 8px 10px;
}
</style>
