<template>
  <div id="app">
    <h2 class="page-main-title">ğŸ·ï¸ íƒœê·¸ ë²ˆí˜¸ ìƒì„¸ ì¡°íšŒ ë° ìœ íš¨ì„± ê²€ì‚¬</h2>

    <div class="main-content-wrapper">
      <!-- â­â­â­ ì¢Œì¸¡: Tag No Pub/Wrk ë°ì´í„° ì¡°íšŒ í™”ë©´ (API) â­â­â­ -->
      <div class="panel api-pubdata-panel">
        <h3 class="panel-title">Tag No. Pub/Wrk ë°ì´í„° ì¡°íšŒ</h3>

        <div class="input-group">
          <label for="tagNoInputApi">ì¡°íšŒí•  Tag No. ì…ë ¥:</label>
          <input
            id="tagNoInputApi"
            v-model="tagNoForApi"
            type="text"
            placeholder="ì˜ˆ: CheckTest009"
            @keyup.enter="searchTag"
          />
        </div>
        <div class="input-group">
          <label for="projectNoInputApi">í”„ë¡œì íŠ¸ ë²ˆí˜¸:</label>
          <input id="projectNoInputApi" v-model="projectNoInput" type="text" placeholder="ì˜ˆ: TE1002" />
        </div>
        <button @click="searchTag" :disabled="apiLoading" class="action-btn primary-btn">API ìƒì„¸ ì¡°íšŒ</button>

        <div v-if="apiLoading" class="message loading-message">API ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>
        <div v-else-if="apiErrorMessage" class="message error-message">ì˜¤ë¥˜ ë°œìƒ: {{ apiErrorMessage }}</div>

        <div
          v-else-if="
            apiSearched &&
            !pubData &&
            (!wrkData || wrkData.length === 0) &&
            (!registerTypeData || registerTypeData.length === 0)
          "
          class="message no-results-message"
        >
          ì…ë ¥í•˜ì‹  Tag No. ({{ apiSearchedTagNo }}) ì— ëŒ€í•œ API ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.
        </div>

        <div
          v-else-if="pubData || (wrkData && wrkData.length > 0) || (registerTypeData && registerTypeData.length > 0)"
        >
          <!-- Pub ë°ì´í„° ê²€ìƒ‰ ê²°ê³¼ -->
          <div class="results-card" v-if="pubData">
            <h4>âœ¨ Pub ë°ì´í„° ê²€ìƒ‰ ê²°ê³¼ (ë‹¨ì¼ í•­ëª©)</h4>
            <p><strong>ì¡°íšŒ Tag No.:</strong> {{ apiSearchedTagNo }}</p>
            <p><strong>EP_ID:</strong> {{ pubData.EP_ID }}</p>
            <p><strong>EP_IC:</strong> {{ pubData.EP_IC }}</p>
            <p><strong>CLS_ID:</strong> {{ pubData.CLS_ID }}</p>
            <p><strong>DELETED:</strong> {{ pubData.DELETED ? 'Yes' : 'No' }}</p>
            <p v-if="pubData.TAG_NO"><strong>ë°ì´í„° Tag No.:</strong> {{ pubData.TAG_NO }}</p>
            <p v-if="pubData.TAG_IDX"><strong>ë°ì´í„° Tag IDX.:</strong> {{ pubData.TAG_IDX }}</p>
            <p v-if="pubData.NEW_YN !== undefined"><strong>NEW_YN:</strong> {{ pubData.NEW_YN ? 'Yes' : 'No' }}</p>
            <p v-if="pubData.DEL_YN !== undefined"><strong>DEL_YN:</strong> {{ pubData.DEL_YN ? 'Yes' : 'No' }}</p>
          </div>

          <!-- Wrk ë°ì´í„° ê²€ìƒ‰ ê²°ê³¼ -->
          <div class="results-card wrk-data-section" v-if="wrkData && wrkData.length > 0">
            <h4>âœ¨ Wrk ë°ì´í„° ê²€ìƒ‰ ê²°ê³¼ (ì—¬ëŸ¬ í•­ëª©)</h4>
            <div v-for="(wrkItem, index) in wrkData" :key="wrkItem._id || index" class="wrk-item">
              <h5>Wrk í•­ëª© #{{ index + 1 }}</h5>
              <p><strong>EP_ID:</strong> {{ wrkItem.EP_ID }}</p>
              <p><strong>EP_IC:</strong> {{ wrkItem.EP_IC }}</p>
              <p><strong>CLS_ID:</strong> {{ wrkItem.CLS_ID }}</p>
              <p><strong>DELETED:</strong> {{ wrkItem.DELETED ? 'Yes' : 'No' }}</p>
              <p v-if="wrkItem.TAG_NO"><strong>ë°ì´í„° Tag No.:</strong> {{ wrkItem.TAG_NO }}</p>
              <p v-if="wrkItem.TAG_IDX"><strong>ë°ì´í„° Tag IDX.:</strong> {{ wrkItem.TAG_IDX }}</p>
              <p v-if="wrkItem.NEW_YN !== undefined"><strong>NEW_YN:</strong> {{ wrkItem.NEW_YN ? 'Yes' : 'No' }}</p>
              <p v-if="wrkItem.DEL_YN !== undefined"><strong>DEL_YN:</strong> {{ wrkItem.DEL_YN ? 'Yes' : 'No' }}</p>
            </div>
          </div>

          <!-- â­ ê´€ë ¨ TYPE_ID"Register ID" ì •ë³´ ì¶”ê°€ â­ -->
          <div class="results-card type-id-section" v-if="registerTypeData && registerTypeData.length > 0">
            <h4>âœ¨ ê´€ë ¨ REGISTER ID ì •ë³´</h4>
            <ul>
              <li v-for="(item, index) in registerTypeData" :key="item._id || index">
                <strong>CLS_ID:</strong> {{ item.CLS_ID }} ({{ item.DESC || 'ì„¤ëª… ì—†ìŒ' }}) â†’
                <strong>REGISTER_ID":</strong>
                {{ item.TYPE_ID }}
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- â­â­â­ ìš°ì¸¡: Tag Split í™”ë©´ (ìœ íš¨ì„± ê²€ì‚¬ê¸°) â­â­â­ -->
      <div class="panel tag-split-panel">
        <h3 class="panel-title">Tag Split (ìœ íš¨ì„± ê²€ì‚¬ê¸°)</h3>

        <div class="input-group">
          <label for="tagNoInputValidator">ê²€ì‚¬í•  Tag No. ì…ë ¥:</label>
          <input id="tagNoInputValidator" v-model="tagNoForValidator" type="text" placeholder="ì˜ˆ: AA-BBB01-0001/A" />
        </div>

        <div class="rules-table-container">
          <h4>ê·œì¹™ ì„¤ì • (ê°„ë‹¨í•œ í…Œì´ë¸”)</h4>
          <p class="panel-description">ê° íƒœê·¸ êµ¬ì„± ìš”ì†Œì˜ êµ¬ë¶„ìì™€ ì •ê·œì‹ì„ ì§ì ‘ í¸ì§‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
          <table>
            <thead>
              <tr>
                <th>TAG ID</th>
                <th>êµ¬ë¶„ì</th>
                <th>ì •ê·œì‹</th>
                <th>ì•¡ì…˜</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="(rule, index) in tagRules" :key="index">
                <td>TAG{{ String(index + 1).padStart(3, '0') }}</td>
                <td><input type="text" v-model="rule.delimiter" maxlength="1" /></td>
                <td><input type="text" v-model="rule.regex" /></td>
                <td><button @click="removeRule(index)" class="action-btn danger-btn">ì‚­ì œ</button></td>
              </tr>
            </tbody>
          </table>
          <div class="table-actions">
            <button @click="addRule" class="action-btn success-btn">ê·œì¹™ ì¶”ê°€</button>
            <button @click="showPasteModal = true" class="action-btn info-btn">ì—‘ì…€ì—ì„œ ë¶™ì—¬ë„£ê¸°</button>
          </div>
        </div>

        <h4 class="section-sub-title">ì „ì²´ íƒœê·¸ ë²ˆí˜¸ ìœ íš¨ì„± ê²€ì‚¬</h4>
        <div class="overall-validation-result">
          <p class="validation-summary">
            ì „ì²´ íƒœê·¸ ë²ˆí˜¸ (`{{ tagNoForValidator }}`)ëŠ” **
            <span :style="{ color: isTagNoValid ? 'green' : 'red', fontWeight: 'bold' }">
              {{ isTagNoValid ? 'ìœ íš¨í•©ë‹ˆë‹¤.' : 'ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' }}
            </span>
            **
          </p>
          <p class="regex-info">
            ì ìš©ëœ ì „ì²´ ì •ê·œì‹: <code class="combined-regex-code">{{ combinedRegexString }}</code>
            <span v-if="combinedRegexError" class="regex-error-msg"> (ì •ê·œì‹ ì˜¤ë¥˜: {{ combinedRegexError }}) </span>
          </p>
        </div>

        <h4 class="section-sub-title">ë¶€ë¶„ë³„ ë¶„ì„ ê²°ê³¼</h4>
        <table class="parts-analysis-table">
          <thead>
            <tr>
              <th>ê·œì¹™</th>
              <th>ë¶„ë¦¬ëœ ê°’</th>
              <th>ì ìš©ëœ ì •ê·œì‹</th>
              <th>êµ¬ë¶„ì ìœ íš¨ì„±</th>
              <th>ë‚´ìš© ìœ íš¨ì„±</th>
              <th>ì¢…í•© ìœ íš¨ì„±</th>
            </tr>
          </thead>
          <tbody>
            <tr v-if="tagRules.length === 0">
              <td colspan="6" class="no-rule-message">ê·œì¹™ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.</td>
            </tr>
            <tr v-if="!tagNoForValidator && tagRules.length > 0">
              <td colspan="6" class="no-input-message">íƒœê·¸ ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</td>
            </tr>
            <tr v-for="(part, index) in tagParts" :key="index">
              <td>
                TAG{{ String(index + 1).padStart(3, '0') }} (ì˜ˆìƒ êµ¬ë¶„ì:
                <span style="font-weight: bold">'{{ part.expectedDelimiter || '(ì—†ìŒ)' }}'</span>)
              </td>
              <td>
                <span
                  :style="{ color: part.matchedValue === undefined || part.matchedValue === null ? '#aaa' : 'inherit' }"
                >
                  {{
                    part.matchedValue === undefined || part.matchedValue === null
                      ? '(ê°’ ì—†ìŒ)'
                      : part.matchedValue === ''
                        ? '(ë¹ˆ ê°’)'
                        : part.matchedValue
                  }}
                </span>
              </td>
              <td>{{ part.regex }}</td>
              <td :style="{ color: part.isDelimiterValid ? 'green' : 'red', fontWeight: 'bold' }">
                {{ part.isDelimiterValid ? 'ìœ íš¨' : part.delimiterError || 'ìœ íš¨í•˜ì§€ ì•ŠìŒ' }}
              </td>
              <td :style="{ color: part.isContentValid ? 'green' : 'red', fontWeight: 'bold' }">
                {{ part.isContentValid ? 'ìœ íš¨' : part.contentError || 'ìœ íš¨í•˜ì§€ ì•ŠìŒ' }}
              </td>
              <td :style="{ color: part.isValid ? 'green' : 'red', fontWeight: 'bold' }">
                {{ part.isValid ? 'ìœ íš¨' : 'ìœ íš¨í•˜ì§€ ì•ŠìŒ' }}
              </td>
            </tr>
            <tr v-if="tagNoForValidator && isTagNoValid === false && tagParts.length > 0 && lastPartError">
              <td colspan="6" class="overall-fail-message">
                <span style="font-weight: bold">ì „ì²´ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {{ lastPartError }}</span>
              </td>
            </tr>
            <tr v-if="tagNoForValidator && isTagNoValid === false && tagParts.length > 0 && !lastPartError">
              <td colspan="6" class="overall-fail-message">
                <span style="font-weight: bold">ì…ë ¥ëœ íƒœê·¸ ë²ˆí˜¸ê°€ ê·œì¹™ê³¼ ì™„ì „íˆ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</span>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- ì—‘ì…€ ë¶™ì—¬ë„£ê¸° ëª¨ë‹¬ (ëª¨ë‹¬ì€ í•­ìƒ ìµœìƒë‹¨ì— ë³´ì´ë„ë¡ main-content-wrapper ë°–ì— ë‘ ) -->
    <div v-if="showPasteModal" class="modal-overlay">
      <div class="modal-content">
        <h4>ì—‘ì…€ ë°ì´í„° ë¶™ì—¬ë„£ê¸°</h4>
        <p>ì—‘ì…€ì—ì„œ ë³µì‚¬í•œ ë°ì´í„°ë¥¼ ì•„ë˜ í…ìŠ¤íŠ¸ ì˜ì—­ì— ë¶™ì—¬ë„£ì–´ ì£¼ì„¸ìš”.</p>
        <textarea
          v-model="pasteData"
          placeholder="ì—¬ê¸°ì— ì—‘ì…€ì—ì„œ ë³µì‚¬í•œ ë°ì´í„°ë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš” (íƒ­ìœ¼ë¡œ êµ¬ë¶„ëœ ê°’)"
          rows="10"
          class="paste-textarea"
        ></textarea>
        <div class="modal-actions">
          <button @click="applyPasteData" class="action-btn success-btn">ì ìš©</button>
          <button @click="showPasteModal = false" class="action-btn cancel-btn">ì·¨ì†Œ</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  // Library - Common
  import { ref, onMounted, onBeforeMount, watch, inject, computed, shallowRef, toRaw } from 'vue'
  // Piniaë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì œê±°í•©ë‹ˆë‹¤. (storeToRefsê°€ ì‚¬ìš©ë˜ëŠ” ë¶€ë¶„ì´ ì—†ì–´ì„œ ì œê±°)
  // import { storeToRefs } from 'pinia';

  // Helpers
  // sAlert, sToast ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì£¼ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
  // import { sAlert, sToast } from '@/utils/messages/alert-common';
  import { axiosWrapper } from '@/utils/axios/axios-wrapper'
  // axiosë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì œê±°í•©ë‹ˆë‹¤.
  // import axios from 'axios';

  export default {
    setup() {
      // --- API Pub Data ì¡°íšŒ ê´€ë ¨ ìƒíƒœ ---
      const tagNoForApi = ref('') // API ì¡°íšŒìš© ë…ë¦½ Tag No. ì…ë ¥
      const projectNoInput = ref('TE1002') // ì˜ˆì‹œ í”„ë¡œì íŠ¸ ë²ˆí˜¸. ì‹¤ì œ ì‚¬ìš© ì‹œ ë³€ê²½í•´ì£¼ì„¸ìš”.
      const apiSearchedTagNo = ref('') // API ê²€ìƒ‰ ì™„ë£Œëœ Tag No. (ê²°ê³¼ í‘œì‹œìš©)

      // PubDataì™€ WrkDataë¥¼ ê°ê° ì €ì¥í•  ìƒíƒœ ë³€ìˆ˜
      const pubData = ref(null)
      const wrkData = ref([])
      const registerTypeData = ref([]) // â­ ìƒˆë¡œìš´ ìƒíƒœ: GetByClassIDs API ê²°ê³¼ ì €ì¥

      const apiLoading = ref(false) // API ê´€ë ¨ ë¡œë”© ìƒíƒœ
      const apiErrorMessage = ref('') // API ê´€ë ¨ ì˜¤ë¥˜ ë©”ì‹œì§€
      const apiSearched = ref(false) // API ê²€ìƒ‰ì´ í•œ ë²ˆì´ë¼ë„ ì‹œë„ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€

      // --- Tag Split (ìœ íš¨ì„± ê²€ì‚¬ê¸°) ê´€ë ¨ ìƒíƒœ ---
      const tagNoForValidator = ref('AP330X01-') // Validatorìš© ë…ë¦½ Tag No. ì…ë ¥
      const combinedRegexError = ref(null)
      const lastPartError = ref(null)

      const tagRules = ref([
        { delimiter: '', regex: '^$|^[A-Z]{2}$' }, // TAG001 (ex: AZ, AP)
        { delimiter: '', regex: '^[0123LCRIT]{3}$' }, // TAG002 (ex: 012, 330)
        { delimiter: '', regex: '^[ABCDEFNVXS]{1}$' }, // TAG003 (í•œ ê¸€ì A/B/C/D/E/F/N/V/X/S, ex: A, X)
        { delimiter: '', regex: '^$|^[ABCDEFNVXS]{1}$' }, // TAG004 (ì˜µì…”ë„, í•œ ê¸€ì A/B/C/D/E/F/N/V/X/S, ex: A, (ê°’ ì—†ìŒ))
        { delimiter: '', regex: '^[0-9]{2}$' }, // TAG005 (ìˆ«ì ë‘ ê¸€ì, ex: 09, 01)
        { delimiter: '-', regex: '^$|^[APS1-9]{2}$' }, // TAG006 (êµ¬ë¶„ì -, ì˜µì…”ë„ ë‘ ê¸€ì A/P/S/1-9, ex: AA, (ê°’ ì—†ìŒ))
      ])

      // ì—‘ì…€ ë¶™ì—¬ë„£ê¸° ëª¨ë‹¬ ê´€ë ¨ ìƒíƒœ
      const showPasteModal = ref(false)
      const pasteData = ref('')

      // --- API Pub/Wrk Data ì¡°íšŒ ë¡œì§ ---
      const searchTag = async () => {
        // ì´ì „ API ê²€ìƒ‰ ê²°ê³¼ ë° ì˜¤ë¥˜ ë©”ì‹œì§€ ì´ˆê¸°í™”
        pubData.value = null // PubData ì´ˆê¸°í™”
        wrkData.value = [] // WrkData ì´ˆê¸°í™”
        registerTypeData.value = [] // â­ GetByClassIDs ê²°ê³¼ë„ ì´ˆê¸°í™”
        apiErrorMessage.value = ''
        apiSearched.value = true // ê²€ìƒ‰ ì‹œë„ í‘œì‹œ

        if (!projectNoInput.value) {
          apiErrorMessage.value = 'í”„ë¡œì íŠ¸ ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'
          return
        }
        if (!tagNoForApi.value) {
          apiErrorMessage.value = 'API ìƒì„¸ ì¡°íšŒë¥¼ ìœ„í•œ Tag No.ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'
          return
        }

        apiLoading.value = true // API ë¡œë”© ìƒíƒœ ì‹œì‘
        apiSearchedTagNo.value = tagNoForApi.value // ê²€ìƒ‰í•  Tag No. ì €ì¥

        try {
          const primaryApiUrl = '/api/Data/GetPubWrkDataByTagNo' // ì²« ë²ˆì§¸ API URL
          const primaryPayload = {
            ProjectNo: projectNoInput.value,
            TAG_NO: tagNoForApi.value,
            ContainDeleted: true,
          }

          const primaryResponse = await axiosWrapper.post(primaryApiUrl, primaryPayload)
          const primaryData = primaryResponse

          if (primaryData) {
            // PubDataì™€ WrkData ì €ì¥
            pubData.value = primaryData.PubData && primaryData.PubData.length > 0 ? primaryData.PubData[0] : null
            wrkData.value = primaryData.WrkData || []

            if (!pubData.value && wrkData.value.length === 0) {
              apiErrorMessage.value = `ì…ë ¥í•˜ì‹  Tag No. (${apiSearchedTagNo.value})ì— ëŒ€í•œ Pub ë˜ëŠ” Wrk ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`
            }

            // â­ CLS_ID ì¶”ì¶œ ë° ë‘ ë²ˆì§¸ API í˜¸ì¶œ ë¡œì§ ì‹œì‘ â­
            const classIDsToFetch = new Set() // ì¤‘ë³µ CLS_ID ì œê±°ë¥¼ ìœ„í•´ Set ì‚¬ìš©
            if (pubData.value && pubData.value.CLS_ID) {
              classIDsToFetch.add(pubData.value.CLS_ID)
            }
            wrkData.value.forEach(item => {
              if (item.CLS_ID) {
                classIDsToFetch.add(item.CLS_ID)
              }
            })

            if (classIDsToFetch.size > 0) {
              const secondaryApiUrl = '/api/Register/GetByClassIDs'
              const secondaryPayload = {
                ProjectNo: projectNoInput.value,
                ClassIDs: Array.from(classIDsToFetch), // Setì„ ë°°ì—´ë¡œ ë³€í™˜
                ContainDeleted: true,
              }
              const secondaryResponse = await axiosWrapper.post(secondaryApiUrl, secondaryPayload)
              registerTypeData.value = secondaryResponse || [] // ê²°ê³¼ ì €ì¥
            }
            // â­ CLS_ID ì¶”ì¶œ ë° ë‘ ë²ˆì§¸ API í˜¸ì¶œ ë¡œì§ ë â­
          } else {
            pubData.value = null
            wrkData.value = []
            registerTypeData.value = []
          }
        } catch (error) {
          console.error('API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error)
          if (error.response) {
            apiErrorMessage.value = `ì„œë²„ ì˜¤ë¥˜: ${error.response.status} - ${error.response.data?.message || error.message}`
            if (error.response.status === 401) {
              apiErrorMessage.value += ' (ì¸ì¦ ì˜¤ë¥˜: ë¡œê·¸ì¸ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.)'
            }
          } else if (error.request) {
            apiErrorMessage.value = 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
          } else {
            apiErrorMessage.value = `ìš”ì²­ ì˜¤ë¥˜: ${error.message}`
          }
        } finally {
          apiLoading.value = false // API ë¡œë”© ìƒíƒœ ì¢…ë£Œ
        }
      }

      // --- Tag Split (ìœ íš¨ì„± ê²€ì‚¬ê¸°) ë¡œì§ (ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼) ---
      const isRegexOptional = regexPattern => {
        const trimmed = regexPattern.trim()
        if (!trimmed) return true
        if (trimmed === '^$') return true
        if (trimmed.startsWith('^$|')) return true

        try {
          const cleanedRegex = trimmed.replace(/^\^/, '').replace(/\$$/, '')
          const regex = new RegExp(`^${cleanedRegex}$`)
          return regex.test('')
        } catch (e) {
          return false
        }
      }

      const combinedRegexString = computed(() => {
        combinedRegexError.value = null
        if (tagRules.value.length === 0) return '^$'

        let regexParts = []
        try {
          tagRules.value.forEach((rule, index) => {
            let currentContentRegex = rule.regex.trim()
            const isRuleContentOptional = isRegexOptional(currentContentRegex)

            let contentPatternOnly = currentContentRegex.replace(/^\^/, '').replace(/\$$/, '')

            let contentPatternForCombination
            if (isRuleContentOptional && contentPatternOnly.includes('$|')) {
              contentPatternOnly = contentPatternOnly.replace('$|', '')
              contentPatternForCombination = `(?:${contentPatternOnly}|)`
            } else {
              contentPatternForCombination = `(?:${contentPatternOnly})`
            }

            let segmentPattern

            if (index > 0 && rule.delimiter.trim() !== '') {
              const escapedDelimiter = rule.delimiter.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&')

              if (isRuleContentOptional) {
                segmentPattern = `(?:${escapedDelimiter}${contentPatternForCombination})?`
              } else {
                segmentPattern = `(?:${escapedDelimiter}${contentPatternForCombination})`
              }
            } else {
              segmentPattern = contentPatternForCombination
            }

            regexParts.push(segmentPattern)
          })

          return `^${regexParts.join('')}$`
        } catch (e) {
          combinedRegexError.value = e.message
          console.error('Combined Regex Generation Error:', e)
          return '.*'
        }
      })

      const isTagNoValid = computed(() => {
        if (combinedRegexError.value) return false

        if (!tagNoForValidator.value && tagRules.value.length === 0) return true
        if (!tagNoForValidator.value && tagRules.value.length > 0) {
          return tagRules.value.every(rule => isRegexOptional(rule.regex))
        }
        if (tagRules.value.length === 0 && tagNoForValidator.value) return false

        try {
          const regex = new RegExp(combinedRegexString.value)
          return regex.test(tagNoForValidator.value)
        } catch (e) {
          console.error('Invalid combined regex for validation:', combinedRegexString.value, e)
          return false
        }
      })

      // ë¶€ë¶„ë³„ ë¶„ì„ ë¡œì§
      const tagParts = computed(() => {
        const parts = []
        let currentTagNo = tagNoForValidator.value || ''
        lastPartError.value = null

        if (!currentTagNo && tagRules.value.length === 0) return []

        if (!currentTagNo && tagRules.value.length > 0) {
          tagRules.value.forEach(rule => {
            parts.push({
              expectedDelimiter: rule.delimiter.trim(),
              matchedValue: null,
              regex: rule.regex,
              isDelimiterValid: true,
              delimiterError: null,
              isContentValid: isRegexOptional(rule.regex),
              contentError: isRegexOptional(rule.regex) ? null : 'í•„ìˆ˜ ê°’ì´ ë¹„ì–´ìˆìŒ',
              isValid: isRegexOptional(rule.regex),
            })
          })
          return parts
        }

        let currentIndex = 0

        for (let i = 0; i < tagRules.value.length; i++) {
          const rule = tagRules.value[i]
          let matchedValue = null
          let isContentValid = false
          let contentError = null
          let isDelimiterValid = true
          let delimiterError = null

          let expectedDelimiter = rule.delimiter.trim()
          let contentRegexRaw = rule.regex.trim()
          let contentRegex = contentRegexRaw.replace(/^\^/, '').replace(/\$$/, '')

          const remainingSegment = currentTagNo.substring(currentIndex)
          const isRuleContentOptional = isRegexOptional(contentRegexRaw)

          if (i > 0 && expectedDelimiter !== '') {
            const delimiterPresentInSegment = remainingSegment.startsWith(expectedDelimiter)

            let contentWillMatchActualValue = false
            if (contentRegex) {
              try {
                contentWillMatchActualValue = new RegExp(`^(${contentRegex})`).test(remainingSegment)
              } catch (e) {
                /* ì •ê·œì‹ ì˜¤ë¥˜ ë¬´ì‹œ */
              }
            }

            if (isRuleContentOptional && !contentWillMatchActualValue) {
              if (delimiterPresentInSegment) {
                isDelimiterValid = false
                delimiterError = `ë¹ˆ ê°’ êµ¬ì„±ìš”ì†Œì— ë¶ˆí•„ìš”í•œ êµ¬ë¶„ì '${expectedDelimiter}' ì¡´ì¬`
              } else {
                isDelimiterValid = true
                delimiterError = null
              }
            } else {
              if (delimiterPresentInSegment) {
                currentIndex += expectedDelimiter.length
                isDelimiterValid = true
                delimiterError = null
              } else {
                isDelimiterValid = false
                delimiterError = `í•„ìˆ˜ êµ¬ë¶„ì '${expectedDelimiter}' ëˆ„ë½`
              }
            }
          }

          const segmentAfterDelimiter = currentTagNo.substring(currentIndex)

          try {
            const matchRegex = new RegExp(`^(${contentRegex})`)
            const match = matchRegex.exec(segmentAfterDelimiter)

            if (match && match[1] !== undefined) {
              matchedValue = match[1]
              currentIndex += matchedValue.length
            } else {
              if (!isRuleContentOptional) {
                contentError = 'í•„ìˆ˜ êµ¬ì„± ìš”ì†Œ ëˆ„ë½'
              }
              matchedValue = null
            }

            const individualRegex = new RegExp(`^${contentRegex}$`)
            isContentValid = individualRegex.test(matchedValue !== null ? matchedValue : '')

            if (!isContentValid && matchedValue === null && isRuleContentOptional) {
              isContentValid = true
              contentError = null
            } else if (!isContentValid && contentError === null) {
              contentError = 'ì •ê·œì‹ ë¶ˆì¼ì¹˜'
            }
          } catch (e) {
            console.error(`ê·œì¹™ TAG${String(i + 1).padStart(3, '0')} ì •ê·œì‹ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:`, rule.regex, e)
            contentError = `ì •ê·œì‹ ì²˜ë¦¬ ì˜¤ë¥˜: ${e.message}`
            isContentValid = false
            matchedValue = null
          }

          const isValid = isDelimiterValid && isContentValid

          parts.push({
            expectedDelimiter: expectedDelimiter,
            matchedValue: matchedValue,
            regex: rule.regex,
            isDelimiterValid: isDelimiterValid,
            delimiterError: delimiterError,
            isContentValid: isContentValid,
            contentError: contentError,
            isValid: isValid,
          })

          if (!isDelimiterValid || !isContentValid) {
            if (delimiterError || contentError) {
              lastPartError.value = `${delimiterError || ''} ${contentError || ''}`.trim()
            }
            return parts
          }
        }

        if (currentIndex < currentTagNo.length) {
          lastPartError.value = `ê·œì¹™ ì™¸ì˜ ì¶”ê°€ ë¬¸ìì—´: '${currentTagNo.substring(currentIndex)}'`
        } else if (currentIndex > currentTagNo.length) {
          lastPartError.value = 'ì˜ˆìƒë³´ë‹¤ ê¸´ íŒ¨í„´ì´ ë§¤ì¹­ë¨ (ë‚´ë¶€ ë¡œì§ ì˜¤ë¥˜ ê°€ëŠ¥ì„±)'
        }

        return parts
      })

      // --- ê·œì¹™ ë° ì—‘ì…€ ê´€ë ¨ í•¨ìˆ˜ (ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼) ---
      const addRule = () => {
        tagRules.value.push({ delimiter: '', regex: '' })
      }

      const removeRule = index => {
        tagRules.value.splice(index, 1)
      }

      const applyPasteData = () => {
        const newRules = []
        const rows = pasteData.value.trim().split('\n')

        rows.forEach(row => {
          const columns = row.split('\t')
          if (columns.length >= 2) {
            newRules.push({
              delimiter: columns[0].trim() || '',
              regex: columns[1].trim() || '',
            })
          } else if (columns.length === 1 && columns[0].trim() !== '') {
            newRules.push({
              delimiter: '',
              regex: columns[0].trim(),
            })
          }
        })

        if (newRules.length > 0) {
          tagRules.value = newRules
        }
        showPasteModal.value = false
        pasteData.value = ''
      }

      return {
        // API Pub Data ì¡°íšŒ ê´€ë ¨
        tagNoForApi,
        projectNoInput,
        apiSearchedTagNo,
        pubData, // PubData ë°˜í™˜
        wrkData, // WrkData ë°˜í™˜
        registerTypeData, // â­ registerTypeData ë°˜í™˜
        apiLoading,
        apiErrorMessage,
        apiSearched,
        searchTag,

        // Tag Split (ìœ íš¨ì„± ê²€ì‚¬ê¸°) ê´€ë ¨
        tagNoForValidator,
        combinedRegexError,
        lastPartError,
        tagRules,
        showPasteModal,
        pasteData,
        isTagNoValid,
        tagParts,
        addRule,
        removeRule,
        applyPasteData,
        combinedRegexString, // templateì—ì„œ computed ì†ì„±ì„ ì§ì ‘ ì‚¬ìš©
      }
    },
  }
</script>

<style scoped>
  /* ê¸°ë³¸ íƒ€ì´í¬ê·¸ë˜í”¼ */
  #app {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 1400px; /* ë‘ íŒ¨ë„ì„ ë‚˜ë€íˆ ë°°ì¹˜í•˜ê¸° ìœ„í•´ ìµœëŒ€ ë„ˆë¹„ ì¦ê°€ */
    margin: 30px auto;
    padding: 30px;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
    background-color: #f8f9fa;
    color: #333;
  }

  .page-main-title {
    color: #2c3e50;
    text-align: center;
    margin-bottom: 40px;
    font-size: 2.5em;
    font-weight: 600;
    border-bottom: 3px solid #4caf50;
    padding-bottom: 15px;
  }

  /* ë©”ì¸ ì»¨í…ì¸  ë˜í¼ (Flexbox ì‚¬ìš©) */
  .main-content-wrapper {
    display: flex;
    gap: 30px; /* íŒ¨ë„ ì‚¬ì´ì˜ ê°„ê²© */
    margin-top: 30px;
    flex-wrap: wrap; /* ì‘ì€ í™”ë©´ì—ì„œ ì»¬ëŸ¼ì´ ìŒ“ì´ë„ë¡ */
    justify-content: center; /* ê°€ìš´ë° ì •ë ¬ */
  }

  .panel {
    flex: 1; /* ë‚¨ì€ ê³µê°„ì„ ê· ë“±í•˜ê²Œ ë¶„ë°° */
    min-width: 450px; /* ê° íŒ¨ë„ì˜ ìµœì†Œ ë„ˆë¹„ ì„¤ì • */
    border: 1px solid #dcdcdc;
    border-radius: 10px;
    padding: 30px;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.05);
    background-color: #ffffff;
    display: flex; /* ë‚´ë¶€ ìš”ì†Œë„ flexë¡œ ì •ë ¬ë  ìˆ˜ ìˆë„ë¡ */
    flex-direction: column;

    /* â­ íŒ¨ë„ ìŠ¤í¬ë¡¤ ì¶”ê°€ â­ */
    max-height: 80vh; /* í™”ë©´ ë†’ì´ì˜ 80%ë¥¼ ìµœëŒ€ ë†’ì´ë¡œ ì„¤ì • */
    overflow-y: auto; /* ë‚´ìš©ì´ max-heightë¥¼ ì´ˆê³¼í•˜ë©´ ìŠ¤í¬ë¡¤ë°” ìƒì„± */
    padding-right: 15px; /* ìŠ¤í¬ë¡¤ë°”ì™€ ë‚´ìš© ì‚¬ì´ ì—¬ë°± í™•ë³´ (ì„ íƒ ì‚¬í•­) */
    box-sizing: border-box; /* íŒ¨ë”©ì´ ë„ˆë¹„/ë†’ì´ì— í¬í•¨ë˜ë„ë¡ */
  }

  .panel-title {
    color: #34495e;
    margin-top: 0;
    margin-bottom: 25px;
    font-size: 2em;
    font-weight: 500;
    padding-bottom: 10px;
    border-bottom: 2px solid #5cb85c;
    text-align: center;
  }

  /* Input Group */
  .input-group {
    margin-bottom: 20px;
  }

  .input-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    color: #555;
    font-size: 0.95em;
  }

  .input-group input[type='text'] {
    width: calc(100% - 24px); /* íŒ¨ë”© ë° ë³´ë” ê³ ë ¤ */
    padding: 12px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1em;
    transition:
      border-color 0.3s ease,
      box-shadow 0.3s ease;
  }

  .input-group input[type='text']:focus {
    border-color: #4caf50;
    outline: none;
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
  }

  /* Action Buttons */
  .action-btn {
    padding: 12px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.05em;
    font-weight: bold;
    transition:
      background-color 0.3s ease,
      transform 0.2s ease;
    width: 100%;
  }

  .action-btn:hover:not(:disabled) {
    transform: translateY(-2px);
  }

  .action-btn:disabled {
    background-color: #e0e0e0;
    color: #a0a0a0;
    cursor: not-allowed;
    transform: none;
  }

  .primary-btn {
    background-color: #007bff;
    color: white;
  }
  .primary-btn:hover:not(:disabled) {
    background-color: #0056b3;
  }

  .success-btn {
    background-color: #28a745;
    color: white;
  }
  .success-btn:hover:not(:disabled) {
    background-color: #218838;
  }

  .info-btn {
    background-color: #17a2b8;
    color: white;
  }
  .info-btn:hover:not(:disabled) {
    background-color: #138496;
  }

  .danger-btn {
    background-color: #dc3545;
    color: white;
  }
  .danger-btn:hover:not(:disabled) {
    background-color: #c82333;
  }

  .cancel-btn {
    background-color: #6c757d;
    color: white;
  }
  .cancel-btn:hover:not(:disabled) {
    background-color: #5a6268;
  }

  /* Message Styles */
  .message {
    padding: 15px;
    border-radius: 6px;
    margin-top: 20px;
    text-align: center;
    font-weight: bold;
    font-size: 0.9em;
  }

  .loading-message {
    background-color: #e0f7fa;
    color: #00796b;
    border: 1px solid #b2ebf2;
  }

  .error-message {
    background-color: #ffebee;
    color: #d32f2f;
    border: 1px solid #ef9a9a;
  }

  .no-results-message {
    background-color: #fffde7;
    color: #fbc02d;
    border: 1px solid #fff59d;
  }

  /* API Results Card */
  .results-card {
    background-color: #e8f5e9;
    border: 1px solid #c8e6c9;
    padding: 20px;
    border-radius: 8px;
    margin-top: 25px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  }

  .results-card h4 {
    color: #2e7d32;
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.3em;
    border-bottom: 1px solid #d4edda;
    padding-bottom: 10px;
  }
  .results-card h5 {
    /* Wrk ë°ì´í„° í•­ëª©ë³„ ì œëª© */
    color: #388e3c;
    font-size: 1.1em;
    margin-top: 20px;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px dotted #c8e6c9;
  }

  .results-card p {
    margin-bottom: 8px;
    line-height: 1.5;
    font-size: 0.95em;
  }

  .results-card p strong {
    color: #388e3c;
    min-width: 100px;
    display: inline-block;
  }

  /* â­ TYPE_ID ì„¹ì…˜ ìŠ¤íƒ€ì¼ â­ */
  .type-id-section ul {
    list-style-type: disc;
    padding-left: 20px;
    margin-top: 10px;
  }
  .type-id-section li {
    margin-bottom: 5px;
    font-size: 0.95em;
    color: #4caf50;
  }
  .type-id-section li strong {
    color: #388e3c;
  }

  /* Validator Panel specific styles */
  .tag-input-display {
    background-color: #e9f7ef;
    border: 1px solid #c8e6c9;
    padding: 10px 15px;
    border-radius: 5px;
    margin-bottom: 25px;
    font-size: 1.1em;
    color: #333;
  }

  .tag-value-display {
    font-weight: bold;
    color: #2e7d32;
  }

  .panel-description {
    color: #777;
    font-size: 0.9em;
    margin-bottom: 15px;
  }

  .rules-table-container {
    margin-bottom: 20px;
  }

  .rules-table-container h4,
  .section-sub-title {
    color: #333;
    margin-top: 30px;
    margin-bottom: 15px;
    font-size: 1.4em;
    padding-bottom: 8px;
    border-bottom: 1px dashed #eee;
  }

  .rules-table-container table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
  }

  .rules-table-container th,
  .rules-table-container td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
    font-size: 0.9em;
  }

  .rules-table-container th {
    background-color: #f2f2f2;
  }

  .rules-table-container input[type='text'] {
    width: calc(100% - 10px);
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 3px;
    box-sizing: border-box;
    font-size: 0.9em;
  }

  .rules-table-container .table-actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
  }

  .overall-validation-result {
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #f9f9f9;
    margin-bottom: 20px;
    font-size: 0.95em;
  }

  .validation-summary {
    margin: 0;
    font-size: 1.1em;
  }

  .regex-info {
    margin-top: 10px;
    font-size: 0.9em;
    color: #666;
  }

  .combined-regex-code {
    background-color: #e9e9e9;
    padding: 3px 6px;
    border-radius: 3px;
    word-break: break-all;
    font-size: 0.9em;
  }

  .regex-error-msg {
    color: red;
    font-size: 0.85em;
    display: block;
    margin-top: 5px;
  }

  .parts-analysis-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
  }

  .parts-analysis-table thead tr {
    background-color: #f2f2f2;
  }

  .parts-analysis-table th,
  .parts-analysis-table td {
    padding: 10px;
    border: 1px solid #ddd;
    text-align: left;
    font-size: 0.85em;
  }

  .no-rule-message,
  .no-input-message,
  .overall-fail-message {
    padding: 12px;
    border: 1px solid #ddd;
    text-align: center;
    color: #999;
    font-size: 0.9em;
  }

  .overall-fail-message {
    color: #cc0000;
    background-color: #ffe0e0;
  }

  /* ëª¨ë‹¬ ìŠ¤íƒ€ì¼ (ìµœìƒë‹¨ z-indexë¡œ ë„ì›€) */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .modal-content {
    background: white;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    width: 90%;
    max-width: 550px;
    box-sizing: border-box;
  }

  .modal-content h4 {
    margin-top: 0;
    color: #333;
    font-size: 1.5em;
  }

  .modal-content p {
    color: #666;
    font-size: 0.95em;
    margin-bottom: 20px;
  }

  .modal-content .paste-textarea {
    width: 100%;
    padding: 12px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1em;
    resize: vertical;
    min-height: 150px;
    box-sizing: border-box;
  }

  .modal-content .modal-actions {
    margin-top: 25px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
  }

  /* ë°˜ì‘í˜• ë””ìì¸ */
  @media (max-width: 1100px) {
    .main-content-wrapper {
      flex-direction: column; /* ì¤‘ê°„ í¬ê¸° í™”ë©´ì—ì„œ ì„¸ë¡œë¡œ ìŒ“ì´ë„ë¡ */
      gap: 30px;
    }
    .panel {
      min-width: unset; /* ìµœì†Œ ë„ˆë¹„ ì œí•œ í•´ì œ */
      width: 100%;
    }
  }

  @media (max-width: 600px) {
    #app {
      padding: 15px;
    }
    .page-main-title {
      font-size: 1.8em;
    }
    .panel-title {
      font-size: 1.5em;
    }
    .input-group input[type='text'],
    .action-btn,
    .modal-content .paste-textarea {
      font-size: 0.9em;
      padding: 10px;
    }
  }
</style>
