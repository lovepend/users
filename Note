const insertRows = function (rowCount) {
  const grid = gridRef.value;
  if (!grid) return;

  grid.stopEditing();
  grid.setGridOption('loading', true);

  const filterModel = grid.getFilterModel();
  const filterDefaults = {};

  /**
   * 필터 모델에서 모든 값을 찾아 '배열'로 반환하는 함수
   */
  const getFilterValuesAsArray = (m) => {
    if (!m || typeof m !== 'object') return [];

    let values = [];

    // 1. Set Filter (이미 values 배열을 가지고 있음)
    if (Array.isArray(m.values)) {
      values = m.values;
    }
    // 2. Multi Filter (보내주신 로그 구조: filterModels 배열 존재)
    else if (m.filterType === 'multi' && Array.isArray(m.filterModels)) {
      m.filterModels.forEach(subModel => {
        if (subModel) {
          const subValues = getFilterValuesAsArray(subModel);
          values = values.concat(subValues);
        }
      });
    }
    // 3. 복합 조건 (conditions 배열)
    else if (Array.isArray(m.conditions)) {
      m.conditions.forEach(cond => {
        const condValues = getFilterValuesAsArray(cond);
        values = values.concat(condValues);
      });
    }
    // 4. 단일 텍스트 필터 (filter 키가 있는 경우)
    else if (m.filter !== undefined) {
      values.push(m.filter);
    }
    // 5. 기타 value 속성
    else if (m.value !== undefined) {
      values.push(m.value);
    }

    // 중복 제거 및 모든 문자열을 대문자로 변환하여 반환
    return [...new Set(values)].map(v => 
      (typeof v === 'string' ? v.trim().toUpperCase() : v)
    );
  };

  // 모든 필터 컬럼 순회하며 배열로 값 추출
  Object.keys(filterModel).forEach((colId) => {
    const valArray = getFilterValuesAsArray(filterModel[colId]);
    if (valArray.length > 0) {
      // 결과가 단일 값이라도 저장 액션을 위해 [ "TEST" ] 형태로 저장
      filterDefaults[colId] = valArray;
    }
  });

  console.log('최종 추출된 배열 필터값:', filterDefaults);

  const addRows = [];
  const numRows = parseInt(rowCount) || 1;

  for (let i = 0; i < numRows; i++) {
    const newId = `new_${Math.random().toString(36).substring(2, 12)}`;
    const newRow = {
      STATUS: 'A',
      PROJ_NO: currentProjNo.value,
      ATT_ID: null,
      CL_ID: null,
      VAL_TYPE: (typeof VAL_TYPES !== 'undefined') ? VAL_TYPES.STRING.VALUE : 'STRING',
      RDON_YN: false,
      IGN_LIST_VAL: false,
      CRTER_NO: userInfo.value?.UserID,
      _id: newId,
      ...filterDefaults // 이제 GROUP: ["TEST"] 와 같은 형식으로 주입됩니다.
    };
    addRows.push(newRow);
  }

  if (addRows.length > 0) {
    // addIndex를 제거하여 전체 데이터의 마지막에 추가 (필터 해제 시 중간 끼임 방지)
    const result = grid.applyTransaction({ add: addRows });
    
    grid.refreshCells({ force: true, suppressFlash: true });
    
    if (result.add && result.add.length > 0) {
      grid.setNodesSelected({ nodes: result.add, newValue: true });
      const lastIdx = grid.getDisplayedRowCount() - 1;
      grid.ensureIndexVisible(lastIdx, 'bottom');
    }
  }
  
  grid.setGridOption('loading', false);
};

// 핸들러 선언 순서 유지
const onCreateRows = function () {
  if (!currentProjNo.value) {
    sAlert.Warning(`Project를 선택해주세요`);
    return;
  }
  insertRows(1);
};

const onCreateMultiRows = function (rowCount) {
  if (!currentProjNo.value) {
    sAlert.Warning(`Project를 선택해주세요`);
    return;
  }
  const count = (typeof rowCount === 'number') ? rowCount : 1;
  insertRows(count);
};
