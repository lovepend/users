<script setup lang="ts">
  import { ref, onMounted } from 'vue'
  import { useAppAuthenticationStore } from '@/stores/app-authentication'
  import { axiosWrapper } from '@/utils/axios/axios-wrapper'
  import * as XLSX from 'xlsx'
  import { ApiCommon } from '@/utils/axios/api-common'
  // @ts-ignore (js 파일이라 타입 에러 날 수 있음)
  import * as SEF from '@/utils/spread/spread-excel-funtions.js'

  /** Variable List */
  const releaseNotesGrouped = ref<any[]>([])
  const isLoading = ref(true)
  const { userInfo } = useAppAuthenticationStore()
  const fileInput = ref<HTMLInputElement | null>(null)
  const fileId = ref<string | null>(null)
  const urlList = { gfi: '/api/File/Get', gfr: '/api/File/Replace' }

  onMounted(() => {
    const baseSiteName = (import.meta as any).env.VITE_BASE_SITENAME
    if (baseSiteName === 'dev') fileId.value = '69827ed36514d58f04e067e7'
    else if (baseSiteName === 'devop') fileId.value = '698963e8ed2aff6e2771b20d'
    else fileId.value = '6982ac8ea605319e04771832'
    fetchAndParseExcel()
  })

  /** 구분선 표시 로직 */
  const isNotLastItem = (index: number): boolean => {
    if (!releaseNotesGrouped.value) return false
    return index < releaseNotesGrouped.value.length - 1
  }

  /** 운영 환경용 버전 날짜 업데이트 (+1일 및 월 변경 처리) */
  const getUpdatedVersionForProd = (version: string): string => {
    const parts: string[] = version.split('.')
    if (parts.length < 2) return version

    const lastPart: string = parts[parts.length - 1] // DD
    const monthPart: string = parts[parts.length - 2] // MM

    const dayNum: number = parseInt(lastPart)
    const monthNum: number = parseInt(monthPart)

    if (isNaN(dayNum) || isNaN(monthNum)) return version

    // 날짜 계산 로직
    const currentYear: number = new Date().getFullYear()
    const date: Date = new Date(currentYear, monthNum - 1, dayNum)
    
    // 하루 더하기 (월 자동 이월 처리됨)
    date.setDate(date.getDate() + 1)

    const newMonth: string = String(date.getMonth() + 1).padStart(2, '0')
    const newDay: string = String(date.getDate()).padStart(2, '0')

    const prefix: string = parts.slice(0, parts.length - 2).join('.')
    // 만약 prefix가 비어있다면 (형식이 MM.DD 만 있을 경우 대비)
    return prefix ? `${prefix}.${newMonth}.${newDay}` : `${newMonth}.${newDay}`
  }

  /** 엑셀 파싱 */
  const parseSheetWithHeaders = (sheet: any, skipRows: number): any[] => {
    if (!sheet) return []
    const rows: any[] = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' })
    if (rows.length <= skipRows) return []

    const headers: string[] = rows[skipRows].map((h: any) => String(h || '').replace(/\s/g, ''))
    const dataRows: any[] = rows.slice(skipRows + 1)
    const getIdx = (name: string) => headers.indexOf(name.replace(/\s/g, ''))

    const idx = {
      autoNo: getIdx('AutoNo'),
      category: getIdx('구분'),
      desc: getIdx('기능요청상세내용'),
      action: getIdx('ACTION부서회신내용'),
      remark: getIdx('Remark(개발)'),
      status: getIdx('STATUS'),
      version: getIdx('완료버젼'),
      part: getIdx('Part'),
    }

    return dataRows
      .map(row => ({
        AutoNo: idx.autoNo !== -1 ? row[idx.autoNo] : '',
        category: idx.category !== -1 ? row[idx.category] : '',
        description: idx.desc !== -1 ? row[idx.desc] : '',
        actionDesc: idx.action !== -1 ? row[idx.action] : '',
        remarkDev: idx.remark !== -1 ? row[idx.remark] : '',
        status: idx.status !== -1 ? row[idx.status] : '',
        completionVersion: idx.version !== -1 ? row[idx.version] : '',
        part: idx.part !== -1 ? row[idx.part] : '',
      }))
      .filter(item => item.status || item.completionVersion)
  }

  const fetchAndParseExcel = async function () {
    try {
      isLoading.value = true
      const baseSiteName = (import.meta as any).env.VITE_BASE_SITENAME
      const isProd = !(baseSiteName === 'dev' || baseSiteName === 'devop')
      
      let allowedStatus: string[] = ['FINISH', 'CHECKED']
      if (!isProd) allowedStatus.push('READY')

      const response: any = await axiosWrapper.postAll(
        urlList.gfi,
        { id: fileId.value },
        { responseType: 'blob', headers: { FileToken: 'frontserver@sh' } }
      )
      const decryptedBlob: any = await ApiCommon.postFileDecryptFile({ FILE: new File([response.data], 'temp.xlsx') })
      const workbook = XLSX.read(await decryptedBlob.arrayBuffer(), { type: 'array' })

      let combined: any[] = []

      workbook.SheetNames.forEach((name, index) => {
        const skip = index === 0 ? 2 : 0
        const sheetData = parseSheetWithHeaders(workbook.Sheets[name], skip)
        combined = [...combined, ...sheetData]
      })

      const grouped: Record<string, any> = {}
      combined.forEach((row: any) => {
        const status = String(row.status || '').trim().toUpperCase()
        let version = String(row.completionVersion || '').trim()

        if (allowedStatus.includes(status) && version) {
          if (isProd) {
            version = getUpdatedVersionForProd(version)
          }

          if (!grouped[version]) grouped[version] = { version: version, items: [] }
          grouped[version].items.push({
            ...row,
            category: String(row.category || '').toLowerCase(),
            status: status,
          })
        }
      })

      releaseNotesGrouped.value = Object.values(grouped).sort((a: any, b: any) =>
        b.version.localeCompare(a.version, undefined, { numeric: true })
      )
    } catch (error) {
      console.error('Error:', error)
    } finally {
      isLoading.value = false
      if (SEF && SEF.onHideOverlay) SEF.onHideOverlay()
    }
  }

  const getBadgeClass = (category: any): string => {
    const c = String(category).toLowerCase()
    if (['오류', 'fixed'].includes(c)) return 'badge bg-gradient-orange-red'
    if (['기능개선', 'changed'].includes(c)) return 'badge bg-gradient-yellow-orange'
    if (['신규기능', 'added'].includes(c)) return 'badge bg-gradient-teal-green'
    return 'badge'
  }

  const getBadgeTextColorClass = (category: any): string => {
    const c = String(category).toLowerCase()
    if (['오류', 'fixed'].includes(c)) return 'text-danger'
    if (['기능개선', 'changed'].includes(c)) return 'text-warning'
    if (['신규기능', 'added'].includes(c)) return 'text-success'
    return 'text-gray'
  }

  const importExcel = () => {
    if (fileInput.value) fileInput.value.click()
  }

  const handleFileUpload = async (event: any) => {
    const file = event.target.files[0]
    if (!file) return
    await axiosWrapper.post(
      urlList.gfr,
      { id: fileId.value, File: file },
      { headers: { 'Content-Type': 'multipart/form-data', FileToken: 'frontserver@sh' } }
    )
    fetchAndParseExcel()
  }
</script>
