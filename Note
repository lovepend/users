const insertRows = function (rowCount) {
  const grid = gridRef.value;
  if (!grid) return;

  grid.stopEditing();
  grid.setGridOption('loading', true);

  // --- [핵심] Step 2 내부에서만 처리하는 필터 우회 로직 ---
  // 1. 외부 필터 로직을 함수 내에서 동적으로 주입합니다.
  grid.setGridOption('isExternalFilterPresent', () => true);
  grid.setGridOption('doesExternalFilterPass', (node) => {
    // 신규 행(STATUS 'A')은 무조건 통과, 나머지는 기본 필터 유지(true)
    if (node.data && node.data.STATUS === 'A') return true;
    return true; 
  });
  // --------------------------------------------------

  const addRows = [];
  const numRows = parseInt(rowCount) || 1;

  for (let i = 0; i < numRows; i++) {
    const newId = `new_${Math.random().toString(36).substring(2, 12)}`;
    addRows.push({
      STATUS: 'A',
      PROJ_NO: currentProjNo.value,
      ATT_ID: null,
      CL_ID: null,
      VAL_TYPE: (typeof VAL_TYPES !== 'undefined') ? VAL_TYPES.STRING.VALUE : 'STRING',
      RDON_YN: false,
      IGN_LIST_VAL: false,
      CRTER_NO: userInfo.value?.UserID,
      _id: newId,
      // 필터 값은 비워둠 (빈 행)
    });
  }

  if (addRows.length > 0) {
    // 행 추가
    const result = grid.applyTransaction({ add: addRows });
    
    // 필터 변경 알림 (이때 위에서 정의한 doesExternalFilterPass가 실행됨)
    grid.onFilterChanged();
    
    grid.refreshCells({ force: true, suppressFlash: true });
    
    if (result.add && result.add.length > 0) {
      const newNode = result.add[0];
      grid.setNodesSelected({ nodes: [newNode], newValue: true });
      
      const lastIdx = grid.getDisplayedRowCount() - 1;
      grid.ensureIndexVisible(lastIdx, 'bottom');

      // 즉시 편집 모드 진입
      setTimeout(() => {
        grid.setFocusedCell(newNode.rowIndex, 'GROUP');
        grid.startEditingCell({
          rowIndex: newNode.rowIndex,
          colKey: 'GROUP'
        });
      }, 50);
    }
  }
  
  grid.setGridOption('loading', false);
};
