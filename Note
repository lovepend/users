<template>
  <div id="app">
    <h2 class="page-main-title">ğŸ·ï¸ íƒœê·¸ ë²ˆí˜¸ ìƒì„¸ ì¡°íšŒ ë° ìœ íš¨ì„± ê²€ì‚¬</h2>

    <div class="main-content-wrapper">

      <!-- ===================== API ì¡°íšŒ íŒ¨ë„ ===================== -->
      <div class="panel api-pubdata-panel">
        <h3 class="panel-title">Tag No. Pub/Wrk ë°ì´í„° ì¡°íšŒ</h3>

        <div class="input-group">
          <label>ì¡°íšŒí•  Tag No. ì…ë ¥:</label>
          <input
            v-model="tagNoForApi"
            type="text"
            @keyup.enter="searchTag"
          />
        </div>

        <div class="input-group">
          <label>í”„ë¡œì íŠ¸ ë²ˆí˜¸:</label>
          <input v-model="projectNoInput" type="text" />
        </div>

        <button
          @click="searchTag"
          :disabled="apiLoading"
          class="action-btn primary-btn"
        >
          API ìƒì„¸ ì¡°íšŒ
        </button>

        <div v-if="apiLoading">ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘...</div>
        <div v-else-if="apiErrorMessage">ì˜¤ë¥˜: {{ apiErrorMessage }}</div>

        <div v-else-if="apiSearched">

          <!-- Pub ì •ë³´ -->
          <div class="results-card" v-if="pubData">
            <h4>âœ¨ Pub ê¸°ë³¸ ì •ë³´</h4>
            <p><strong>TAG_NO:</strong> {{ pubData.TAG_NO }}</p>
            <p><strong>EP_ID:</strong> {{ pubData.EP_ID }}</p>
            <p><strong>CLS_ID:</strong> {{ pubData.CLS_ID }}</p>
          </div>

          <!-- Wrk ë¦¬ìŠ¤íŠ¸ -->
          <div
            class="results-card"
            v-if="wrkData && wrkData.length > 0"
          >
            <h4>âœ¨ Wrk ë°ì´í„° ë¦¬ìŠ¤íŠ¸ ({{ wrkData.length }}ê±´)</h4>

            <div
              v-for="(wrkItem, index) in wrkData"
              :key="wrkItem._id || index"
              class="wrk-item"
            >
              <div>
                <span class="badge">Wrk #{{ index + 1 }}</span>
                <strong>{{ wrkItem.EP_ID }} / {{ wrkItem.TAG_IDX }}</strong>
              </div>

              <p><strong>DEL_YN:</strong> {{ wrkItem.DEL_YN ? 'Yes' : 'No' }}</p>

              <!-- ğŸ”¥ ì¶”ê°€ëœ Pub ì¡´ì¬ í‘œì‹œ -->
              <div class="pub-check-line">
                <span
                  v-if="wrkItem.hasPub"
                  class="pub-exist"
                >
                  âœ” Pub ì¡´ì¬
                </span>
              </div>

            </div>
          </div>

        </div>
      </div>

      <!-- ===================== ìœ íš¨ì„± ê²€ì‚¬ íŒ¨ë„ ===================== -->
      <div class="panel tag-split-panel">
        <h3 class="panel-title">Tag Split (ìœ íš¨ì„± ê²€ì‚¬ê¸°)</h3>

        <div class="input-group">
          <label>ê²€ì‚¬í•  Tag No. ì…ë ¥:</label>
          <input v-model="tagNoForValidator" type="text" />
        </div>

        <table>
          <thead>
            <tr>
              <th>êµ¬ë¶„ì</th>
              <th>ì •ê·œì‹</th>
              <th>ê´€ë¦¬</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(rule, index) in tagRules" :key="index">
              <td><input v-model="rule.delimiter" /></td>
              <td><input v-model="rule.regex" /></td>
              <td>
                <button @click="removeRule(index)">X</button>
              </td>
            </tr>
          </tbody>
        </table>

        <button @click="addRule">ê·œì¹™ ì¶”ê°€</button>

        <div class="overall-validation-result">
          <p>
            ì¢…í•© ìœ íš¨ì„±:
            <span :class="{ 'valid-txt': isTagNoValid, 'invalid-txt': !isTagNoValid }">
              {{ isTagNoValid ? 'ìœ íš¨í•¨(PASS)' : 'ìœ íš¨í•˜ì§€ ì•ŠìŒ(FAIL)' }}
            </span>
          </p>
        </div>
      </div>

    </div>
  </div>
</template>

<script>
import { ref, computed } from 'vue'
import { axiosWrapper } from '@/utils/axios/axios-wrapper'

export default {
  setup() {

    // ================= API =================
    const tagNoForApi = ref('')
    const projectNoInput = ref('TE1002')
    const pubData = ref(null)
    const wrkData = ref([])
    const apiLoading = ref(false)
    const apiErrorMessage = ref('')
    const apiSearched = ref(false)

    const searchTag = async () => {
      pubData.value = null
      wrkData.value = []
      apiErrorMessage.value = ''
      apiSearched.value = true
      apiLoading.value = true

      try {
        const res = await axiosWrapper.post(
          '/api/Data/GetPubWrkDataByTagNo',
          {
            ProjectNo: projectNoInput.value,
            TAG_NO: tagNoForApi.value,
            ContainDeleted: true
          }
        )

        if (res) {
          pubData.value = res.PubData?.[0] || null
          const rawWrk = res.WrkData || []

          const enhancedWrk = await Promise.all(
            rawWrk.map(async (item) => {

              if (!item.TAG_IDX) {
                return { ...item, hasPub: false }
              }

              try {
                const detailRes = await axiosWrapper.post(
                  '/api/Data/GetPubDataByID',
                  {
                    ProjectNo: projectNoInput.value,
                    TAG_IDX: item.TAG_IDX,
                    ContainDeleted: true
                  }
                )

                return { ...item, hasPub: !!detailRes }

              } catch {
                return { ...item, hasPub: false }
              }
            })
          )

          wrkData.value = enhancedWrk
        }

      } catch (err) {
        apiErrorMessage.value = err.message
      } finally {
        apiLoading.value = false
      }
    }

    // ================= ìœ íš¨ì„± ê²€ì‚¬ =================
    const tagNoForValidator = ref('')
    const tagRules = ref([
      { delimiter: '', regex: '^$|^[A-Z]{2}$' },
      { delimiter: '', regex: '^[0123LCRIT]{3}$' },
      { delimiter: '', regex: '^[ABCDEFNVXS]{1}$' },
      { delimiter: '-', regex: '^[0-9]{2}$' }
    ])

    const isRegexOptional = r => r.startsWith('^$|')

    const combinedRegexString = computed(() => {
      let parts = tagRules.value.map((rule, i) => {
        let p = rule.regex.replace(/^\^|\$$/g, '')
        let s = `(?:${p})`
        if (i > 0 && rule.delimiter) {
          const d = rule.delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
          s = isRegexOptional(rule.regex)
            ? `(?:${d}${s})?`
            : `(?:${d}${s})`
        }
        return s
      })
      return `^${parts.join('')}$`
    })

    const isTagNoValid = computed(() => {
      try {
        return new RegExp(combinedRegexString.value)
          .test(tagNoForValidator.value)
      } catch {
        return false
      }
    })

    const addRule = () => tagRules.value.push({ delimiter: '', regex: '' })
    const removeRule = i => tagRules.value.splice(i, 1)

    return {
      tagNoForApi,
      projectNoInput,
      pubData,
      wrkData,
      apiLoading,
      apiErrorMessage,
      apiSearched,
      searchTag,
      tagNoForValidator,
      tagRules,
      isTagNoValid,
      addRule,
      removeRule
    }
  }
}
</script>
